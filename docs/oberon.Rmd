---
title: "Order book events reconstruction from empirical data"
subtitle: A preliminary draft
author: "Petr Fedorov"
date: "`r Sys.Date()`"
header-includes: 
output:
  bookdown::gitbook:
    number_sections: TRUE
    figure_captions: TRUE

bibliography: oberon.bib    
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(scipen = 999, digits = 6, digits.secs=6)
library(data.table)
library(huxtable)
library(magrittr)
library(tibble)
library(ggplot2)
library(gridExtra)
library(latex2exp)


#futile.logger::flog.threshold(futile.logger::WARN, 'obadiah')

```

```{r load data, include=FALSE}
load("oberon.Rdata")
```




 
# Introduction{#index}


## Continuous-time double auction and LOB


Today, most liquid markets – including stocks, futures, and foreign exchange – are electronic, and adopt a continuous-time double auction mechanism using a limit order book (LOB), in which a transaction occurs whenever a buyer and a seller agree on a price[@bouchaud_trades_2018]. Cryptocurrency exchanges are not exception. 

The mechanics of the continuous double auction or LOB trading may be briefly described as follows: 

1. Traders submit *limit orders* and *market* orders 
2. *Market* orders are [matched](https://www.investopedia.com/terms/m/matchingorders.asp) with *limit orders*  and (often) executed to produce *trades*.
3. Unmatched amounts of *limit orders* reside in LOB's queues until matched with another *market* order or cancelled by the trader who submitted it.

Market orders are also often called *takers* (of liquidity) while limit orders sitting in queues are called *makers* (of liquidity).

Note that not all matched orders are necessarily executed to produce trades. If a market order and a matched limit order are placed by the same trader, an execution would lead to a self-trade.  So called self-match or self-trade prevention rules stipulate that in this situation some or both of the matched orders have to  be cancelled instead of being executed. See for example [CME Globex Self-Match Prevention](https://www.cmegroup.com/globex/trade-on-cme-globex/self-match-faq.html) or [Coinbase Markets Trading Rules 2.4 Self-trade prevention](https://www.coinbase.com/legal/trading_rules).

Thus even if one can figure out from an exchange provided data that a market order has been placed, he can deduce neither whether the trade(s) is going to be produced from the market order nor the amount of the trade(s).  In order to reconstruct the dynamics of the countinous-time double auction completely one needs information about all submitted limit and market orders as well as about all trades produced. As we will see below not all exchanges provide this information. 


## Available data sets

Most of data sets containing information about orders and trades consist of two separate loosely coupled files: a **trades** file recording  trades and an **orders** file recording limit and sometimes market order placements, changes and cancellations. Loosely coupled in this context means that records in **trades** file do not always have clearly identifiable corresponding records in **orders** file as one would expect since by definition every trade should change some limit order. A matching or *coupling* procedure is required in order to establish the link between the **trades** and **orders** files in order to

* Distinguish between limit order changes due to cancellation and market order execution
* Calculate sizes of submitted market orders

and, overall, to achieve the ultimate goal - to perform a complete order book reconstruction at every moment of time.

A recently published book [@abergel_limit_2016] uses the [Thomson Reuters Tick History (TRTH)](https://www.refinitiv.com/en/financial-data/market-data/tick-history) database tells us that

> Because one cannot distinguish market orders from cancellations just by observing changes in the limit order book (the “event” file), and since, the time stamps of the “trade” and “event” files are asynchronous, we use a matching procedure to reconstruct the order book events.

The reported matching rate of the above procedure is about 85% for CAC 40 stocks and as a byproduct the procedure outputs the sign of each matched trade, that is whether it is a buyer or a seller initiated trade. Note that TRTH data set does not even provide information about trade direction, it has to be deduced!

The description of similar issues we find in [@hautsch_modelling_2004]:

> A typical problem occurs when trades and quotes are recorded in separate trade and quote databases, like, for example, in the Trade and Quote (TAQ) database released by the NYSE. In this case, it is not directly identifiable whether a quote which has been posted some seconds before a transaction was already valid at the corresponding trade.

[Websocket API v2](https://www.bitstamp.net/websocket/v2/) of the cryptocurrency exchange Bitstamp gives access to the following information for every instrument traded:

 * **Live ticker** channel - information about trades. Unique ids of participating limit and market order are provided for every trade,
 * **Live orders** channel - information about limit and market orders (all order creation, change and deletion events are reported).

As we will see later, events in these channels are not always sent in correct order. Sometimes some events appears to be omitted. Time stamps in Live tickers and Live orders channels are not synchronized: market order, changes of limit orders and of market order itself caused by the execution of the market order, trades produced - all may have different time stamps. Substantial amount of orders which appears to be matched are not executed due to [self-trade prevention](https://www.reddit.com/r/Bitstamp/comments/bbvut2/bitstamp_api_behaviour/?utm_source=share&utm_medium=web2x) policy of Bitstamp.
 

Similarly [Websocket API version 2.0]() of the cryptocurrency exchange Bitfinex have the following channels (for every instrument traded):

 * **Trades** channel - information about trades. Ids of participating limit and market orders are not provided,
 * **Raw book** channel - provides information about 100 best bid and 100 ask limit orders. Market orders are not reported at all. A limit order is reported as deleted when it falls beyond 100+ best limit orders and as re-created (i.e. with the same id) if it returns back. What happens to the order after it has fallen beyond 100+ is not known: Bitfinex allows traders to change the price and volume of submitted limit order, so the order can be changed, cancelled or stay unchanged. 
 
As well as at Bitstamp, records in Trades and Raw book channels are not synchronized.

It should be clear from the above that substantial effort is required to reconstruct the true dynamics of order submission, matching and execution.

# Methods

## Overview

Figure \@ref(fig:oberon-package-overview) shows UML2 Activity Diagram [@cook_omg_2017] of two functions implemented in R package `oberon` which together realize the order book events reconstruction process:

  * `oberon::obtain()` - connects to the specified exchange, obtains available information for the specified pair and saves it as a set of JSON lines with an exchange-specific names into Messages file,
  * `oberon::reconstruct()` - takes Messages file, produced by `oberon::obtain()`, reconstructs Order Table as defined by \@ref(def:order-table), i.e. produces a set of an exchange-independent Events as defined by \@ref(def:order-event), and saves the set into Events file in CSV format.

```{r oberon-package-overview, echo=FALSE, fig.cap="UML2 Activity Diagram  of a standalone application using Reconstruction algorithm", fig.align="center"}
knitr::include_graphics("Oberon package overview.png", dpi=80)
```

`oberon::obtain()` subscribes to the exchange's websocket channel(s) providing information about events and trades for the specified pair. Then it starts an era, i.e. it requests a snapshot of the order book for the specified pair and synchronises the stream of messages it's already receiving from the websocket with the snapshot. As soon as the synchronization is completed, the snapshot itself and the messages that represents an update of the snapshot are being saved to the output file. It is important to note that messages are saved in the order of events as they had happened on the exchange, not in the order they have been received. `Receive and arrange messages` activity performs buffering and re-arranging of the messages before saving them as JSON lines.

The `exchange name` parameter tells `oberon::reconstruct()` which kind of reconstructor object needs to be created to process the Messages file. Every line of the file is transformed into [Boost.Property Tree](https://www.boost.org/doc/libs/1_73_0/doc/html/property_tree.html) container by `Read next message` activity. The container is then passed to `R.1 Reconstruct Order Book` activity, described in details in section \@ref(reconstruction-process). This activity represents the core of the reconstruction algorithm.  The output of `R.1 Reconstruct Order Book` is a set of an exchange-independent order events, whch also carries information about trades. The events are saved into Events file in CSV format.

Surprisingly, an order, an order event, a limit order book,  the operations of a continuous double auction are rather complicated things if one attempts to define them rigorously. Consider, for example,  a definition given in the recent book [@bouchaud_trades_2018]:


> An order is a commitment, declared at a given submission time, to buy or sell a given volume of an asset at no worse than a given price. An order $x$ is thus described by four attributes:
>
> * its sign (or direction) $\epsilon = \pm 1$, ($\epsilon_x = +1$ for buy orders; $\epsilon_x = −1$ for sell orders),
  * its price $p_x$ ,
  * its volume $v_x > 0$, and
  * its submission time $t_x$.
>  
> We introduce the succinct notation $x := (\epsilon_x , p_x ,v_x, t_x )$.

[@bouchaud_trades_2018] then continues with a description of what they call The Trade-Matching Algorithm:

> Whenever a trader submits a buy (respectively, sell) order $x$, an LOB’s *trade-matching algorithm* checks whether it is possible for $x$ to match to existing sell (respectively,buy)orders $y$ such that $p_y \leq p_x$ (respectively, $p_y \geq p_x$). If so, the matching occurs immediately and the relevant traders perform a trade for the agreed amount at the agreed price. Any portion of $x$ that does not match instead becomes active at the price $p_x$, and it remains active until either it matches to an incoming sell (respectively, buy) order or it is cancelled. Cancellation usually occurs when the owner of an order no longer wishes to offer a trade at the stated price.

The above definition and description are incomplete:

* According to the definition, an order $x$ seems to be an immutable entity. But according to the Trade-Matching algorithm, a portion of $x$ may become 'active' and it is not clear how the quality of being 'active' is different from the mere existence of submitted orders,

* At what price the trade is performed - $p_x$ or $p_y$ - is not explicitly stated,

* It is not stated what will happen if $v_x \leq v_y$, etc. 

Below we propose stricter definitions that address these and the other similar issues while staying as close as possible to [@bouchaud_trades_2018].


## Mathematical formulation

### Basic Tools


```{definition Support, name="Support", label=support}
Suppose $X \subset \mathbb{R}$ and $f : X \mapsto \mathbb{R}$. The support of $f$ is defined as the closure of the subset of $X$ where $f$ is non-zero: 
  $$
    \text{supp}(f) = \overline{\{x : x \in X, f(x) \neq 0 \}}
  $$

```


```{definition Piecewise Constant Function, name="Piecewise Constant Function", label=piecewise-constant}
A function $f : \mathbb{R} \mapsto \mathbb{R}$ is called a piecewise constant function if it can be written as 
$$ 
  f(t) = \sum_{T_k \in \mathcal{T} } f_k \mathbf{1}_{T_k}(t)
$$
where  

 a. $\mathcal{T} = \{T_k\}_{k=1}^{K}$ is a set of proper intervals of $\mathbb{R}$ with endpoints $t_{k,1} \in \mathbb{R}$, $t_{k,2} \in \mathbb{R} \cup \{+\infty\}$, $t_{k,1} < t_{k,2}$ such that $\forall k_1 \neq k_2 : T_{k_1} \cap T_{k_2} = \emptyset$, 
 
 a. $\mathbf{1}_{T_k}(\cdot)$ is an indicator function of interval $T_k$: 
$$
\mathbf{1}_{T_k}(t) = \begin{cases} 1, & t \in T_k \\ 0, & t \not \in T_k  \end{cases}
$$
 a. $f_k \in \mathbb{R}$ are constants called *function values* such that $\forall k_1 \neq k_2 : f_{k_1} \neq f_{k_2}$
```

All piece-wise constant functions we use hereafter must also have either left or right (or both) limits at every point of their domains. So in our definition of piece wise constant function set $\mathcal{T}$ does not include  degenerate intervals. 


```{definition Volume Function, name="Volume Function", label="volume-function"}
A function $v : \mathbb{R} \mapsto \mathbb{R}_{\geq 0}$ or $v : \mathbb{R} \mapsto \mathbb{R}_{\leq 0}$ such that

 a. $v(\cdot)$ is a piecewise constant function as defined by \@ref(def:piecewise-constant) with values in the set $\{ n v_0 : n \in \mathbb{Z}\setminus \{0\} \}$ where $v_0$ is a constant called *lot size*,
 b. $v(\cdot)$ is either càdlàg or càglàd at each point of discontinuity 
 
is called a *volume function*.
```


```{definition Filled Volume, name="Filled Volume", label=fill-volume}
Suppose a volume function $v(t)$ as defined by \@ref(def:volume-function) is given. The function 
  $$
  f_{v}(t) = \lim_{t^{'} \uparrow t} v(t^{'}) - v(t)
  $$ is called a *filled volume* at time $t$.  

```


```{definition Amended Volume, name="Amended Volume", label=amended-volume}
Suppose a volume function $v(t)$ as defined by \@ref(def:volume-function) is given. The function 
  $$
  a_{v}(t) = v(t) - \lim_{t^{'} \downarrow t} v(t^{'})
$$ is called an *amended* volume at time $t$.

```



```{r Sample Order Table Data, include=FALSE}
time_0 <- as.POSIXct('2020-04-02 13:59:57', origin='1970-01-01 00:00:00')
sot <- tribble( ~i, ~n,   ~t,   ~f, ~e,   ~p,   ~v,
                1,   1,	  0.3,   0,	 1,	50,	200,
                1,   2,	  3.1,   1,	 0,	50,	200,
                2,   1,	  1.1,   0,	 1,	80,  -200,
                2,   2,	  1.9,   0,	 1,	80,  -100,
                2,   3,	  4.3,   0,	 0,	80,  -100,
                3,   1,	  2.5,   0,	 1,	25,  500,
                3,   2,	  3.1,   2,	 0,	25,  500,
                4,   1,	  3.1,   0,	 1,	25,  -500,
                4,   2,	  5.0,   3,	 0,	25,	-500,
                5,   1,	  3.7,   0,	 1,	50,  -400,
                5,   2,	  5.0,   4,	 1,	50,  -100,
                5,   3,	  5.4,   5,	 0,	50,  -100,
                6,   1,	  4.8,   0,	 1,	10,	500,
                6,   2,	  5.4,   0,	 1,	60,	400,
                6,   3,	  6.0,   6,	 1,	20,	100,)
setDT(sot)
sot[ ,"volume.decrease" := nafill(shift(v,1),fill=0) - nafill(xor(1,xor(e,1)*f)*v,fill=0), by=i]

sot.intervals <- sot[,
                   .(t_1=t,
                     t_2=shift(t, fill=max(sot$t) + 0.4, type="lead"), # infinity is emulated by max(sot$t) + 0.2                            
                     n=n,
                     e,
                     p.p = nafill(shift(p,type="lag"),fill=0),
                     p, 
                     p.v=nafill(shift(v,type="lag"), fill=0), 
                     v,
                     f,
                     volume.decrease),
                   by=i ]


sample.colours <- c('1'='#66bd63', # 'Buy order 1'
             '2'='#f46d43', # 'Sell order 2'
             '3'='#1a9850', # Buy order 3'
             '4'='#d73027', # 'Sell order 4'
             '5'='#a50026', # Sell order 5'
             '6'='#006837' # 'Buy order 6'
             )
sample.labels <- c('1'='Order 1 (buy)',
                                '2'='Order 2 (sell)',
                                '3'='Order 3 (buy)',
                                '4'='Order 4 (sell)',
                                '5'='Order 5 (sell)',
                                '6'='Order 6 (buy)')



```



```{definition Price Function, name="Price Function", label="price-function"}
A function $p : \mathbb{R} \mapsto \mathbb{R}_{\geq 0}$ such that

 a. $p(\cdot)$ is a piecewise constant function as defined by \@ref(def:piecewise-constant) with values in the set $\{ n \vartheta : n \in \mathbb{Z}\setminus \{0\} \}$ where $\vartheta$ is a constant called *tick size*
 b. $p(\cdot)$ is a càglàd at each point of discontinuity 
 
is called a *price function*.
```

The lot size $v_0$ and tick size $\vartheta$ are collectively called *resolution parameters*.

### Order and Trade


Hereafter is assumed that a single asset is traded and a single currency is used. 

As it has already been mentioned above an order is a commitment at a given time, to buy or sell a given volume of an asset at no worse than a given price. Figure \@ref(fig:order-life-cycle) shows UML2 State Machine of High-level Order Life Cycle while the order is being processed by an exchange.  The possible states an order can be in are:

 * *Taker* - a valid order has just been received by an exchange or its price has been changed in such a way that it may be filled immediately. This state is fleeting.
 * *Maker* - the order is open on the order book. Orders which are not fully filled or cancelled immediately enters this state. This state is lasting.
 

```{r order-life-cycle, echo=FALSE, fig.cap="States of an order while it being processed by an exchange", fig.align="center"}
knitr::include_graphics("order-life-cycle.png", dpi=80)
```

An order which has ever entered Maker state is called a [limit order](https://www.investopedia.com/terms/l/limitorder.asp). 

An order which has never entered Maker state is called a [market order](https://www.investopedia.com/terms/m/marketorder.asp).

If an order has been *matched* before entering *Maker* state or it has been *matched* after *price amendment*, then the order is sometimes called a market limit order.  We always model market limit orders as a combination of an appropriate market order and a limit order that placed simultaneously. 

Market orders are always fleeting. To model an evolution of a limit order we use the following function:

```{definition Order, name="Order", label=order}
Suppose that $i \in \mathbb{N}$ is an *unique order identification*, $v^i(t)$ is a volume function as defined by \@ref(def:volume-function), $p^i(t)$ is a price function as defined by \@ref(def:price-function) such that $$\text{supp}\,(v^i) = \text{supp}\,(p^i)$$ Then a vector-valued function $o^i : \mathbb{R} \mapsto \mathbb{R}_{>0} \times \mathbb{R}$ representing a commitment to buy or sell a given volume $v^i(t)$ of an asset at no worse than a given price $p^i(t)$ at a particular time $t$  with a closed form $$o^i(t) = (p^i(t), v^i(t))$$ is called an *order*. If $\forall t : v^i(t) \leq 0$ the order is a commitment to *sell* and is also called a *sell order*. If $\forall t : v^i(t) \geq 0$ the order is a commitment to *buy* and is also called a *buy order*.
```


Now we can define

```{definition Order Volume, name="Order Volume", label=order-volume}
The function $v^i(t)$ in definition \@ref(def:order) is called an *order volume*.
```


```{definition Order Price, name="Order Price", label=order-price}
The function $p^i(t)$ in definition \@ref(def:order) is called an *order price*.
```


```{definition Trade, name="Trade", label=trade}
Suppose an order $o^i(t)$ is given and $\exists t_j : f_{v^i}(t_j) \neq 0$. Then a tuple $$(t_j, i,p^i(t_j), f_{v^i}(t_j))$$ is called a *trade*. If $f_{v^i}(t_j) < 0$ or, equivalently, $i$ is a sell order, then the trade is a buy trade. Otherwise it is a sell trade.

```


Note that we follow [@bouchaud_trades_2018] while modelling the actions of an order owner:

> ... we will consider the evolution of an LOB $\mathcal{L}(t)$ as a so-called *càglàd process (continu à gauche, limite à droite)*. Informally, this means that when a new order $x$ is submitted at time $t_x$ , we regard it to be present in the LOB immediately after its arrival, but not immediately upon its arrival.

In other words, definition \@ref(def:amended-volume) means that when order $v$ is cancelled at time $t$, we regard the cancellation visible in the LOB immediately after its arrival, but not immediately upon its arrival. 

Trades are modeled as *càdlàg (continue à droite, limite à gauche)* occurrences so they are visible immediately upon arrival.  

The consequence of the above is that $v(t)$ can be interpreted as a amount available for trade at time $t$ as it should and if a cancellation and a trade happen simultaneously, the trade is executed.


An order can be conveniently represented in the form of a order table defined by \@ref(def:order-table).


```{definition Order Event, name="Order Event", label=order-event}

An *order event* is a tuple $(i, n, t^i_n,s^i_n, p^i_n, v^i_n,f^i_n)$ where

a. $i \in \mathbb{N}$ is an *unique order identification* of the order,
a. $n \in \{1, \ldots, N^i\}$ is an *order event number*, 
b. $t^i_n \in \mathbb{R}_{>0}$ is an *event timestamp*
b. $s^i_n \in \{0, 1\}$ is the *state* of the order after the event; $s^i_n = 1$ means *Active*, $s^i_n = 0$ means that order is done (finished) i.e. not active,
b. $p_n^i \in \mathbb{R}_{>0}$ is the *order price*,
b. $v_n^i \in \mathbb{R}$ is the *order volume*,
b. $f^i_n \in \mathbb{Z}_{\geq 0}$ is a *trade identification number*; $f^i_n > 0$ indicates that the event is originated by a trade. $f^i_n = 0$ means that the event is not originated by a trade.
```



```{definition Order Table, name="Order Table", label=order-table}

An *order table* is a set of *order events* as defined by \@ref(def:order-event) such that

b. $\forall i, \forall n: t^i_n < t^i_{n+1}$, 
b. $\forall i : s^i_1 = 1$ and $\forall n \in \{2, \ldots, N^i\} : s^i_n = 0 \implies s^i_{n-1} = 1$,
b. $\forall i$ and $\forall n \in \{2, \ldots, N^i\} : f^i_n = 1 \implies p^i_n = p^i_{n-1} \land |v^i_n| < |v^i_{n-1}|$,
b. $\forall i, \forall n_1, n_2: \text{sgn}(v_{n_1}^i) = \text{sgn}(v_{n_2}^i)$,
```




```{theorem Order Table Equivalence,label=equivalence}
There is one-to-one correspondance between orders as defined by \@ref(def:order) and order tables as defined by \@ref(def:order-table).

```

TBD - more constraints to be added to the definition of Order Table. Otherwise the theorem can't be proved.

### Limit Order Book (LOB)

Typically the term [order book](https://www.investopedia.com/terms/o/order-book.asp) refers to an electronic list of buy and sell orders for a specific security or financial instrument organized by price level. An order book lists the number of shares being bid on or offered at each price point, or market depth. Order books are used by almost every exchange to list the orders for different securities. 


```{definition Order Book, name="Order Book", label=order-book}
A set of orders with common resolution parameters $v_0$ and $\vartheta$ $\mathcal{O} = \{o^i(\cdot)\}_i$ where $o^i(\cdot)$ is defined by \@ref(def:order) is called an *order book*. 

A (possibly empty) subset $\mathcal{B} =\{o^b(\cdot)\}_{v^b(\cdot) \geq 0} \subset \mathcal{O}$ of buy orders is called *bids*.  A (possibly empty) subset of *bids* $\mathcal{B}(t) =\{o^b(\cdot)\}_{v^b(\cdot) \geq 0 \land p^b(t) > 0} \subset \mathcal{B}$ of buy orders is called *bids* at time $t$.

A (possibly empty) subset $\mathcal{A} =\{o^a(\cdot)\}_{v^a(\cdot) \leq 0} \subset \mathcal{O}$ of sell orders is called *asks*. A (possibly empty) subset of *asks* $\mathcal{A}(t) =\{o^a(\cdot)\}_{v^a(\cdot) \leq 0 \land p^a(t) > 0} \subset \mathcal{A}$ of buy orders is called *asks* at time $t$.
```

From definition of an order \@ref(def:order) follows that $\mathcal{O} = \mathcal{A} \cup \mathcal{B}$ and $\mathcal{A} \cap \mathcal{B} = \emptyset$.


```{definition Best Bid Price, name="Best Bid Price", label=best-bid-price}
Suppose an order book $\mathcal{O}$ is given.  The function $b(t)$ defined as:
  $$
  b_{\mathcal{O}}(t) = \begin{cases} \max_{o^b(\cdot) \in \mathcal{B}(t)} p^b(t), & \text{ if } \mathcal{B}(t) \neq \emptyset \\0, & \text{ otherwise }  \end{cases}
  $$ is called *best bid price*.
```


```{definition Best Ask Price, name="Best Ask Price", label=best-ask-price}
Suppose an order book $\mathcal{O}$ is given. The function $a(t)$ defined as:
  $$
  a_{\mathcal{O}}(t) = \begin{cases} \min_{o^a(\cdot) \in \mathcal{A}(t)} p^a(t) & \text{ if } \mathcal{A}(t) \neq \emptyset \\ +\infty, & \text{ otherwise } \end{cases}
  $$ is called *best ask price*
```


```{definition Spread, name="Spread", label=spread}
Suppose an order book $\mathcal{O}$ is given and $a_{\mathcal{O}}(t)$ and $b_{\mathcal{O}}(t)$ are its best ask price and best bid price functions as defined by \@ref(def:best-ask-price) and \@ref(def:best-bid-price) respectively. Then the function $$
  s_{\mathcal{O}}(t) = a_{\mathcal{O}}(t) -  b_{\mathcal{O}}(t) 
  $$ is called *spread*.
```


```{definition Limit Order Book, name="Limit Order Book", label=lob}
Suppose an order book $\mathcal{L}$ as defined by \@ref(def:order-book) is given.  Then $\mathcal{L}$ is called a *Limit Order Book (LOB)* if its spread function as defined by \@ref(def:spread) is always positive:
$$ 
  \forall t: s_{\mathcal{L}}(t) > 0
$$
```



A [market order](https://www.investopedia.com/terms/m/marketorder.asp) is a request by an investor to buy or sell a security at the best available price at the time of order placement. The request is usually made through a broker or brokerage service and is ultimately executed by an exchange that maintains an order book.  Clearly, a market order cause an exchange's order book to be updated so market orders are modeled as *changes* of an order book. 


```{definition Market Buy Order, name="Market Buy Order", label=market-buy-order}
Suppose a Limit Order Book $\mathcal{L}$ is given as defined by \@ref(def:lob). Suppose that at time $t_j$ $$\sum_{o^a(\cdot) \in \mathcal{A(t_j)} } f_{v^a}(t_j) < 0 $$ Then it is said that a *market buy order* is placed and executed at time $t_j$ for $\sum_{o^a(\cdot) \in \mathcal{A}(t_j) } |f_{v^a}(t_j)p^a(t_j)|$ units of currency.  

```


```{definition Market Sell Order, name="Market Sell Order", label=market-sell-order}
Suppose a Limit Order Book $\mathcal{L}$ is given as defined by \@ref(def:lob). Suppose that at time $t_j$ $$\sum_{o^b(\cdot) \in \mathcal{B}(t_j) } f_{v^b}(t_j) > 0 $$ Then it is said that a *market sell order* is placed and executed at time $t_j$ for $\sum_{o^b(\cdot) \in \mathcal{B}(t_j) } f_{v^b}(t_j)$ units of asset.  

```



To make the above definitions intuitively clear, let's consider an example. Table \@ref(tab:example-order-table) contains a consolidated order table for six limit orders 



```{r Sample Order Table Print, echo=FALSE}
as_hux(sot[order(t),
           .( `#`=.I,
              `\\(i\\)`=sprintf("%010i", i),
              `\\(n\\)`=n,
              `\\(t^i_n\\)`=format(time_0 + t, "%H:%M:%OS1"),
              `\\(s^i_n\\)`=e,
              `\\(p^i_n\\)`=p,
              `\\(v^i_n\\)`=v,
              `\\(f^i_n\\)`=f,
               `\\(\\Delta v^i_n \\)`=fifelse(v*volume.decrease > 0 & n > 1, volume.decrease, NA_real_)
                 )]) %>%
  add_colnames() %>%
  set_width(0.9) %>%
  set_align(everywhere, c(1:5), 'center') %>%
  set_align(1, c(6:9), 'right') %>%
  set_right_border(everywhere,1, 1) %>%
  set_left_border(everywhere,9, 1) %>%
  set_caption('(#tab:example-order-table) The sample order table contains information about six limit orders, four market orders and six trades.') %>%
  set_caption_pos("topleft") %>%
  set_position("left")



```


Figure \@ref(fig:example-order-book) shows price and volume functions for six limit orders in table \@ref(tab:example-order-table).

```{r example-order-book, fig.height= 7, echo=FALSE, fig.cap="Price and Volume functions for the limit orders in table \\@ref(tab:example-order-table)"}
p <- ggplot(mapping=aes(x=t_1, y=p, colour=as.character(i),   group=as.character(i))) + 
  geom_segment(aes(xend=t_2,yend=p),
               sot.intervals[e ==1 ],
               size=2,
               show.legend=F
               ) + 
  geom_point(data=sot.intervals[e==1 & p != p.p], fill="white", size=4, show.legend=F, shape="circle filled") + 
  geom_point(data=rbind(sot.intervals[e==0, .(t_1, p=p, i) ],
                        sot.intervals[e==1 & p != p.p & n > 1, .(t_1, p=p.p, i) ]
  ),
                        fill="white", size=4, show.legend=F, shape="circle") +
  scale_color_manual("", values=sample.colours ) + 
  scale_x_continuous("", breaks=sot$t, minor_breaks=NULL, labels=NULL) +  
  scale_y_continuous("Price", breaks=c(0, unique(sot$p)), minor_breaks=NULL, limits=c(0,80))+
  theme(legend.position = "none") 

v <- ggplot(mapping=aes(x=t, y=v, colour=as.character(i),  group=as.character(i))) + 
  geom_segment(aes(xend=t_2,yend=v),
               sot.intervals[e ==1, .(t = t_1, t_2, v, e, i) ],
               size=2
               ) + 
  geom_point(data=rbind(sot.intervals[e==1 & v != p.v & f == 0,  .(t = t_1, v, e, i) ],
                        sot.intervals[f != 0,.(t = t_1, v=p.v, e, i)]),
             fill="white", size=4, show.legend=F, shape="circle filled") +
  geom_point(data=rbind(sot.intervals[e==0 & f == 0, .(t = t_1,  v, e, i)],
                        sot.intervals[e==1 & v != p.v & f != 0,  .(t = t_1, v, e, i)],
                        sot.intervals[e==1 & v != p.v & f == 0 & n > 1,  .(t = t_1, v=p.v, e, i)]),
             fill="white", size=4, show.legend=F, shape="circle") + 
  scale_color_manual("", 
                       values=sample.colours,
                       labels=sample.labels) +
  scale_y_continuous("Volume", trans="reverse",
                     breaks=c(0, unique(sot$v)),
                     minor_breaks=NULL
                     ) + 
  scale_x_continuous("Time", breaks=sot$t,
                     labels=format(time_0 + sot$t, "%H:%M:%OS1"),
                     minor_breaks=NULL) +
  scale_shape_manual("Interval", values=c("closed"="circle", "open"="circle filled")) +
  theme(legend.position = "bottom", axis.text.x = element_text(angle = 30, hjust=1))
grid.arrange(p,v, heights=c(3,4))

```
It can bee seen from figure \@ref(fig:example-order-book) that:

  * At `r format(time_0 + sort(unique(sot$t))[1], "%H:%M:%OS1")` order 1 to buy 200 units of the asset at price no worse than 50 per unit has been placed,
  * At `r format(time_0 + sort(unique(sot$t))[2], "%H:%M:%OS1")` order 2 to sell 200 units of the asset at price no worse than 80 per unit has been placed,
  * At `r format(time_0 + sort(unique(sot$t))[3], "%H:%M:%OS1")` the volume of order 2 has been amended (reduced by half) by the trader who placed the order,
  * At `r format(time_0 + sort(unique(sot$t))[4], "%H:%M:%OS1")` order 3 to buy 500 units of the asset at price no worse than 25 per unit has been placed,
  * At `r format(time_0 + sort(unique(sot$t))[5], "%H:%M:%OS1")` order 4 to sell 500 units of the asset at price no worse than 25 has been placed. Exactly at the same time, a market order has been placed to sell 700 units of the asset and two  *sell* trades has been  executed: $(\text{`r format(time_0 + sort(unique(sot$t))[4], "%H:%M:%OS1")`}, 1, 50, 200)$ and $(\text{`r format(time_0 + sort(unique(sot$t))[4], "%H:%M:%OS1")`}, 3, 25, 500)$. Since the market order and order 4 have been placed at exactly the same time, it is very likely that order 4 has actually been placed to sell 1200 units, partially executed and the reminder (i.e. 500 units) has landed in LOB and there were no market order. Nevertheless fundamentally it is still a combination of a market order and a limit order. 
* At `r format(time_0 + sort(unique(sot$t))[6], "%H:%M:%OS1")` order 5 to sell 400 units of the asset at price no worse than 50 per unit has been placed,
* At `r format(time_0 + sort(unique(sot$t))[7], "%H:%M:%OS1")` order 2 has been cancelled,  
* At `r format(time_0 + sort(unique(sot$t))[8], "%H:%M:%OS1")` order 6 to buy 500 units of the asset at price no worse than 10 per unit has been placed,
* At `r format(time_0 + sort(unique(sot$t))[9], "%H:%M:%OS1")` a market order to buy the asset for 27500 units of the currency has been placed and two buy trades have been executed: $(\text{`r format(time_0 + sort(unique(sot$t))[9], "%H:%M:%OS1")`}, 4, 25, -500)$ and $(\text{`r format(time_0 + sort(unique(sot$t))[9], "%H:%M:%OS1")`}, 5, 50, -300)$. Alternatively, it could be a limit order to buy 800 units of the asset at price no worse than 50 that was fully executed. 
* At `r format(time_0 + sort(unique(sot$t))[10], "%H:%M:%OS1")` volume and price of order 6 have been amended. Its volume has been reduced by 100 units of the asset and its price increased to 60. At the same time a market buy order has been placed for 5000 units of the currency and single trade has been executed: $(\text{`r format(time_0 + sort(unique(sot$t))[9], "%H:%M:%OS1")`}, 5, 50, -100)$. Most likely the change of price of order 6 has transformed it to a market limit order which was partially executed and the reminder was placed in the order book again. 
* At `r format(time_0 + sort(unique(sot$t))[11], "%H:%M:%OS1")` a sell market order has been placed, single trade was executed: $(\text{`r format(time_0 + sort(unique(sot$t))[11], "%H:%M:%OS1")`}, 6, 60, 300)$ and, simultaneously, probably as a consequence of the trade, the price of order 6 has been amended from 60 to 20. Note that trade has been executed at price 60.


## Reconstruction process{#reconstruction-process}

Figure \@ref(fig:reconstruction-activity) shows UML2 Activity Diagram of `R.1 Reconstruct Order Book` activity of `oberon::reconstruct()` function.


```{r reconstruction-activity, echo=FALSE, fig.cap="UML2 Activity Diagram  of Reconstruction algorithm", fig.align="center"}
knitr::include_graphics("R.1 Reconstruct Order Book.png", dpi=80)
```

The activity `R.2 Extract` takes a [Boost.PropertyTree](https://www.boost.org/doc/libs/1_73_0/doc/html/property_tree.html) container with an exchange-specific data and produces one or more internal exchange-independent messages. The produced messages belong to the classes shown on figure \@ref(fig:message-hierarchy). 


```{r message-hierarchy, echo=FALSE, fig.cap="UML2 Class Diagram of internal exchange-independent message types used by Order Book Reconstruction algorithm", fig.align="center"}
knitr::include_graphics("Message Hierarchy.png", dpi=80)
```

These messages are then taken by the activity `R.3 Cleanse` that performs so called *data cleansing*. According to [@rahm_data_2000]:

> *Data cleaning*, also called *data cleansing* or *scrubbing*, deals with detecting and removing errors and inconsistencies from data in order to improve the quality of data.

UML2 Activity Diagram [@cook_omg_2017] of `R.3 Cleanse` is shown on figure \@ref(fig:cleanse-activity).

```{r  cleanse-activity, echo=FALSE,fig.cap="UML2 Activity Diagram  of cleansing", fig.align="center"}
knitr::include_graphics("R.3 Cleanse.png", dpi=80)
```

The output of `R.3 Cleanse` is a set of zero or more messages each of which is then converted into zero or one event as defined by \@ref(def:order-event) which together compose Limit Order Book as defined by \@ref(def:lob). These events are persisted by `R.4 Save` activity.

`R.3 Cleanse` will not produce output for a message when subsequent messages are required for cleansing. In this case the message will be kept within `R.3 Cleanse` between runs until enough subsequent messages are received. Then all kept and cleansed messages are returned together.

### Extract

TBD

### Cleanse



```{r  redundant-base, echo=FALSE, fig.cap="States of an order while it being processed by an exchange", fig.align="center"}
knitr::include_graphics("redundant0.png", dpi=80)
```

```{r  redundant-variant1, echo=FALSE, fig.cap="States of an order while it being processed by an exchange", fig.align="center"}
knitr::include_graphics("redundant1.png", dpi=80)
```


```{r  redundant-variant2, echo=FALSE, fig.cap="States of an order while it being processed by an exchange", fig.align="center"}
knitr::include_graphics("redundant2.png", dpi=80)
```



# Results

## Fragments of extracted events

In the tables below the output of `R.2 Extract` is immediately, i.e. without cleansing, converted to events by `R.4 Save`. 

### Coinbase


```{r Sample Coinbase Extracted Events, eval=TRUE, echo=FALSE}

as_hux(coinbase.extracted[,
                    .(`#`=.I,
                    `\\(i\\)(maker)`=substr(maker_order_id,25, 36), `\\(n\\)`=event_no, `\\(t^i_n\\)`=format(timestamp,format="%H:%M:%OS3"), `\\(s^i_n\\)`=state, `\\(p^i_n\\)`=price, `\\(v^i_n\\)`=volume, `\\(f^i_n\\)`=trade_id, `\\(\\Delta v^i_n \\)`=delta_volume, `taker`=substr(taker_order_id, 25,36) ) ],  scientific=F) %>% add_colnames() %>% set_align(1, c(2,4,5,10), 'center') %>% set_align(everywhere, c(1,3, 6:9), 'right') %>% set_number_format(row=everywhere, col=6:7,value="%.2f") %>% set_number_format(row=everywhere, col=9,value="%.3f") %>% set_left_border(everywhere,9, 1) %>% set_right_border(everywhere,1, 1) %>% set_na_string(everywhere, everywhere, "NA") %>% set_caption('(#tab:stamp-quote-frag) A fragment of ETHUSD stream extracted from data generated by Coinbase during 1 second. Coinbase sends correct data and cleansing is not needed.') %>%
  set_caption_pos("topleft")
  
```


### Bitstamp


```{r bitstamp-hux-output, include=FALSE}


as_hux_event_table <- function(data, capt, rows.to.show = NULL) {
  if (is.null(rows.to.show))
    rows.to.show <- seq(1, nrow(data))
  as_hux(data[,
              .(
                `#` = .I,
                `\\(i\\)(maker)` = substr(maker_order_id, 25, 36),
                `\\(n\\)` = event_no,
                `\\(t^i_n\\)` = format(timestamp, format = "%H:%M:%OS3"),
                `\\(s^i_n\\)` = state,
                `\\(p^i_n\\)` = price,
                `\\(v^i_n\\)` = volume,
                `\\(f^i_n\\)` = trade_id,
                `\\(\\Delta v^i_n \\)` = delta_volume,
                `taker` = substr(taker_order_id, 25, 36)
              )][rows.to.show,],
         scientific = F) %>%
    add_colnames() %>%
    set_align(1, c(2, 4, 5, 10), 'center') %>%
    set_align(everywhere, c(1, 3, 6:9), 'right') %>%
    set_number_format(row = everywhere,
                      col = 6:7,
                      value = "%.2f") %>%
    set_number_format(row = everywhere, col = 9, value = "%.3f") %>%
    set_left_border(everywhere, 9, 1) %>%
    set_right_border(everywhere, 1, 1) %>%
    set_na_string(everywhere, everywhere, "NA") %>%
    set_caption(capt) %>%
    set_caption_pos("topleft")
}

```


```{r Sample Bitstamp Extracted Events, eval=TRUE, echo=FALSE}
as_hux_event_table(bitstamp.extracted,'(#tab:stamp-quote-frag) A fragment of ETHUSD stream extracted from data generated by Bitstamp during 1 second. Rows were received in the order shown in the table. This order is sometimes different from the order in which events have happened on the exchange, see, for example, rows 86 and 87. Bitstamp sends duplicate events and correct class of a received event can not always be determined immediately, so cleansing is required.')
```


### Bitfinex 


Table \@ref(tab:finex-extracted) shows information which can be extracted from data provided by Bitfinex.

The exchange does not provide any information about *market* orders.

Trades are reported by Bitfinex without specifying identification numbers of orders involved (see, for example, line 17). Since Bitfinex trading rules allows a trader to place [Hidden orders](https://support.bitfinex.com/hc/en-us/articles/115003451049-Bitfinex-Order-Types#h_01EDSHX0VBHSX36HFD3A1N3R2E), one may expect to see trades out of the blue since, as it is already said, market orders are not reported and the matched limit order could be a hidden one.

Every ~800 milliseconds Bitfinex sends an update of "200 best LOB orders" set.

The update starts from the list of order identification numbers which have to be removed from "200 best LOB orders" set. The reason of removal is not specified by Bitfinex: the removed order could be cancelled, filled or it could just fall beyound 200 best (see, for example, lines 18-24). Since Bitfinex allows to change the price of a placed order even an order with a last known price that is far from spread may be suddenly filled if the trader who placed the order decides to change the order's price. 

Then update ends by the list of orders to be added to "200 best LOB orders" set. Price and remaining size are provided for each order as well as an order identification number (see lines 25-34). 

```{r Sample Bitfinex Extracted Events, eval=TRUE, echo=FALSE}
as_hux_event_table(bitfinex.extracted,'(#tab:finex-extracted) A fragment of order table which can be extracted from Bitfinex\'s Raw Book and Trades websockets data provided for ETHUSD pair during 1 second. Rows are shown in the order they were received from Bitfinex.' )
```


  
## Fragments of cleansed data


### Bitstamp

```{r Sample Bitstamp Cleansed Events, eval=TRUE, echo=FALSE}
deleted.rows <- which(bitstamp.cleansed$is_deleted) + 1
as_hux_event_table(bitstamp.cleansed,'(#tab:stamp-cleansed-quote-frag) A fragment of ETHUSD stream extracted from data generated by Bitstamp during 1 second. Red rows are deleted by the cleansing step.') %>%
  set_background_color(deleted.rows, col=everywhere, value="red")

```


```{r Bitstamp Cleansed Events Example, eval=TRUE, echo=FALSE}
as_hux_event_table(bitstamp.cleansed,'(#tab:stamp-duplicated) Row 16 is deleted since it is a duplicate of row 12. Rows 14 and 15 are related to the taker order 615591571456 so they are deleted too.', c(12, 14:16))

```



```{r visualise-one-second-changes, echo=FALSE, message=FALSE, warning=FALSE, fig.cap="A graphical representation of the evolution of a market depth during 1 second, which is calculated from changing limit orders only. Tick size is $0.1 and sample period is 0.1 second."}

bitstamp.visualise <- bitstamp.cleansed.full[between(timestamp, '2020-03-25 12:17:23+03', '2020-03-25 12:17:24+03') | between(next_timestamp, '2020-03-25 12:17:23+03', '2020-03-25 12:17:24+03') , ][order(timestamp)]
t <- oberon::grid(bitstamp.visualise[(!is_deleted),][order(timestamp)], 139.5,142.5, 0.1,  lubridate::ymd_hms('2020-03-25 12:17:23+03'), lubridate::ymd_hms('2020-03-25 12:17:24+03'),"deci")
small <- 0.0000001
r <- seq(min(t$z)-small, max(t$z), length.out=100)
asks <- c(r[1:(which.max(r >= 0)-1)], -small)
bids <- c(small, r[which.max(r >= 0):length(r)])
col <- c(colorRampPalette(c("blue", "white"))(length(asks)),colorRampPalette(c("white", "red"))(length(bids))[2:length(bids)]) 

layout(matrix(c(2,1), ncol = 2), width=c(1, 4))
image(t,  breaks=c(asks, bids), col=col, axes=F)
axis.POSIXct(1, at=as.POSIXct(t$x+0.005, origin="1970-01-01"), format="%H:%M:%OS1",las=2, lwd=0.1, tck=1)
axis(2, at=t$y[seq(2, length(t$y),2)], las=1,lwd=0.1, tck=1)
plot.new()
levels <- c(asks, bids)
plot.window(xlim = c(0, 1), ylim = rev(range(levels)), xaxs = "i", yaxs = "i")
rect(0, head(levels,-1), 1, tail(levels,-1), col=col, lty="blank")
axis(2)
mtext("Volume", line = 1)

```



```{r visualise-one-second-all, echo=FALSE, message=FALSE, warning=FALSE, fig.cap="A graphical representation of the evolution of a market depth during 1 second, which is calculated from all known limit orders. Tick size and sample period are the same as on the previous figure."}
bitstamp.visualise <- bitstamp.cleansed.full[between(timestamp, '2020-03-25 12:17:23+03', '2020-03-25 12:17:24+03') | between(next_timestamp, '2020-03-25 12:17:23+03', '2020-03-25 12:17:24+03') | (timestamp <'2020-03-25 12:17:23+03' & next_timestamp > '2020-03-25 12:17:23+03'), ][order(timestamp)]
t <- oberon::grid(bitstamp.visualise[(!is_deleted),][order(timestamp)], 139.5,142.5, 0.1,  lubridate::ymd_hms('2020-03-25 12:17:23+03'), lubridate::ymd_hms('2020-03-25 12:17:24+03'),"deci")
small <- 0.0000001
r <- seq(min(t$z)-small, max(t$z), length.out=100)
asks <- c(r[1:(which.max(r >= 0)-1)], -small)
bids <- c(small, r[which.max(r >= 0):length(r)])
col <- c(colorRampPalette(c("blue", "white"))(length(asks)),colorRampPalette(c("white", "red"))(length(bids))[2:length(bids)]) 

layout(matrix(c(2,1), ncol = 2), width=c(1, 4))
image(t,  breaks=c(asks, bids), col=col, axes=F)
axis.POSIXct(1, at=as.POSIXct(t$x+0.005, origin="1970-01-01"), format="%H:%M:%OS1",las=2, lwd=0.1, tck=1)
axis(2, at=t$y[seq(2, length(t$y),2)], las=1,lwd=0.1, tck=1)
plot.new()
levels <- c(asks, bids)
plot.window(xlim = c(0, 1), ylim = rev(range(levels)), xaxs = "i", yaxs = "i")
rect(0, head(levels,-1), 1, tail(levels,-1), col=col, lty="blank")
axis(2)
mtext("Volume", line = 1)
```

# Discussion

TBD





# References





```{r Stub vars for sql chunks, include=FALSE, echo=FALSE}
con <- NULL
bitstamp.quotes <- NULL
bitstamp.trades <- NULL
bitfinex.quotes <- NULL
bitfinex.trades <- NULL
coinbase.quotes <- NULL
coinbase.trades <- NULL
coinbase.full <- NULL

```


```{r Create connection to the database, eval=FALSE, echo=FALSE}
conn <- obadiah::connect("192.168.3.5", "5433", dbname = "obadiah-devel", use.cache=F, user="ob-analytics")
con <- conn$con()
```


```{sql sql - bitstamp.quotes, eval=FALSE, echo=FALSE, connection=con, output.var=bitstamp.quotes}
select * from bitstamp.transient_live_orders 
where era between '2020-03-25 11:27:12.829+03' and '2020-03-26 18:50:59.555+03'
order by microtimestamp;


```


```{sql sql - bitstamp.trades, eval=FALSE, echo=FALSE, connection=con, output.var=bitstamp.trades}
select * from bitstamp.transient_live_trades
where trade_timestamp between '2020-03-25 11:27:12.829+03' and '2020-03-26 18:50:59.555+03' order by trade_timestamp

```

```{r add missing order_created event to Bitstamp, eval=FALSE, include=FALSE}
r <- data.table(order_id=1213590606602240, amount=0.28548526, event='order_created', order_type='sell',  datetime=as.POSIXct('2020-03-25 11:27:13', origin="1970-01-01"), microtimestamp=as.POSIXct('2020-03-25 11:27:12.828', origin="1970-01-01"), local_timestamp=as.POSIXct('2020-03-25 11:27:13.054939', origin="1970-01-01"), pair_id=3, price=142, era=as.POSIXct('2020-03-25 11:27:12.828', origin="1970-01-01"))
class(r$order_type) <- "pq_direction"
class(r$event) <- "pq_live_orders_event"
bitstamp.quotes <- rbind(r, bitstamp.quotes)

```


```{sql sql - bitfinex.quotes, eval=FALSE, echo=FALSE, connection=con, output.var=bitfinex.quotes}
select * from bitfinex.transient_raw_book_events
where channel_id = 11230
order by exchange_timestamp

```




```{sql sql - bitfinex.trades, eval=FALSE, echo=FALSE, connection=con, output.var=bitfinex.trades}
select * from bitfinex.transient_trades
where channel_id = 206
order by exchange_timestamp

```



```{sql sql - coinbase.full, eval=FALSE, echo=FALSE, connection=con, output.var=coinbase.full}
select *
from coinbase.full
order by _time, _type
```



```{r Load Bitstamp data, eval=FALSE, echo=FALSE,}
load(file="bitstamp.Rdata")
setDT(bitstamp.trades)
setDT(bitstamp.quotes)
```

```{r Load Bitfinex data, eval=FALSE, echo=FALSE}
load(file="bitfinex.Rdata")
setDT(bitfinex.trades)
setDT(bitfinex.quotes)

```

```{r Load Coinbase data, eval=FALSE, echo=FALSE}
load(file="coinbase.Rdata")
setDT(coinbase.full)
# Interesting seconds
dcast(coinbase.full[`_type` != 'match', .N, by=ceiling_date(`_time`)][coinbase.full[`_type` == 'match', .N, by=.(ceiling_date(`_time`), `_side`)], on="ceiling_date"][order(-(N*i.N))], ceiling_date + N ~ `_side`, value.var="i.N")[!is.na(buy)& !is.na(sell), ][order(ceiling_date)]

```


```{r Prepare oberon.Rdata, eval=FALSE, echo=FALSE,}
coinbase.extracted <- reconstruct("Coinbase", coinbase.full[`_time` <= '2020-04-01 16:51:57',], extract.only=TRUE)[lubridate::ceiling_date(timestamp) == '2020-04-01 16:51:57',]
setDT(bitstamp.quotes)
setDT(bitstamp.trades)
bitstamp.extracted <- reconstruct("Bitstamp", bitstamp.quotes[microtimestamp <= '2020-03-25 12:17:24+03',], bitstamp.trades[trade_timestamp <= '2020-03-25 12:17:24+03',], extract.only = TRUE)[lubridate::ceiling_date(timestamp) == '2020-03-25 12:17:24+03',]
#[timestamp <= '2020-03-25 12:17:24+03' & next_timestamp >= '2020-03-25 12:17:23+03',]
bitstamp.extracted <- bitstamp.extracted[order(local_timestamp)]

output <- reconstruct("Bitstamp", bitstamp.quotes[microtimestamp <= '2020-03-25 12:17:24+03',], bitstamp.trades[trade_timestamp <= '2020-03-25 12:17:24+03',], extract.only = FALSE)


bitstamp.cleansed.full <- reconstruct("Bitstamp", bitstamp.quotes[microtimestamp <= '2020-03-25 12:17:24+03',], bitstamp.trades[trade_timestamp <= '2020-03-25 12:17:24+03',], extract.only = FALSE)
bitstamp.cleansed <- bitstamp.cleansed.full[lubridate::ceiling_date(timestamp) == '2020-03-25 12:17:24+03',][order(local_timestamp)]
setDT(bitfinex.quotes)
setDT(bitfinex.trades)
bitfinex.extracted <- reconstruct("Bitfinex",
                                  bitfinex.quotes[exchange_timestamp <= '2020-03-26 07:01:34+03',],
                                  bitfinex.trades[exchange_timestamp <= '2020-03-26 07:01:34+03'],
                                  extract.only = TRUE)[lubridate::ceiling_date(timestamp) == '2020-03-26 07:01:34+03',] 
save( coinbase.extracted, bitstamp.extracted, bitstamp.cleansed, bitstamp.cleansed.full, bitfinex.extracted, file="oberon.Rdata", compress=TRUE)

```





