---
title: "Order book events reconstruction from empirical data"
subtitle: A preliminary draft
author: "Petr Fedorov"
date: "`r Sys.Date()`"
header-includes: 
output: 
  bookdown::gitbook:
    toc_depth: 4
    number_sections: TRUE
    figure_captions: TRUE

bibliography: oberon.bib    
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(data.table)
library(huxtable)
library(magrittr)
library(tibble)
library(ggplot2)
library(gridExtra)
library(latex2exp)
options(scipen = 999, digits = 6, digits.secs=6)
#options(huxtable.add_colnames = FALSE)

#futile.logger::flog.threshold(futile.logger::WARN, 'obadiah')

```

```{r load data, include=FALSE}
load("oberon.Rdata")
```




 
# Introduction{#index}


## Continuous-time double auction and LOB


Today, most liquid markets – including stocks, futures, and foreign exchange – are electronic, and adopt a continuous-time double auction mechanism using a limit order book (LOB), in which a transaction occurs whenever a buyer and a seller agree on a price[@bouchaud_trades_2018]. Cryptocurrency exchanges are not exception. 

The mechanics of the continuous double auction or LOB trading may be briefly described as follows: 

1. Traders submit *limit orders* and *market* orders 
2. *Market* orders are [matched](https://www.investopedia.com/terms/m/matchingorders.asp) with *limit orders*  and (often) executed to produce *trades*.
3. Unmatched amounts of *limit orders* reside in LOB's queues until matched with another *market* order or cancelled by the trader who submitted it.

Market orders are also often called *takers* (of liquidity) while limit orders sitting in queues are called *makers* (of liquidity).

Note that not all matched orders are necessarily executed to produce trades. If a market order and a matched limit order are placed by the same trader, an execution would lead to a self-trade.  So called self-match or self-trade prevention rules stipulate that in this situation some or both of the matched orders have to  be cancelled instead of being executed. See for example [CME Globex Self-Match Prevention](https://www.cmegroup.com/globex/trade-on-cme-globex/self-match-faq.html) or [Coinbase Markets Trading Rules 2.4 Self-trade prevention](https://www.coinbase.com/legal/trading_rules).

Thus even if one can figure out from an exchange provided data that a market order has been placed, he can deduce neither whether the trade(s) is going to be produced from the market order nor the amount of the trade(s).  In order to reconstruct the dynamics of the countinous-time double auction completely one needs information about all submitted limit and market orders as well as about all trades produced. As we will see below not all exchanges provide this information. 


## Available data sets

Most of data sets containing information about orders and trades consist of two separate loosely coupled files: a **trades** file recording  trades and an **orders** file recording limit and sometimes market order placements, changes and cancellations. Loosely coupled in this context means that records in **trades** file do not always have clearly identifiable corresponding records in **orders** file as one would expect since by definition every trade should change some limit order. A matching or *coupling* procedure is required in order to establish the link between the **trades** and **orders** files in order to

* Distinguish between limit order changes due to cancellation and market order execution
* Calculate sizes of submitted market orders

and, overall, to achieve the ultimate goal - to perform a complete order book reconstruction at every moment of time.

A recently published book [@abergel_limit_2016] uses the [Thomson Reuters Tick History (TRTH)](https://www.refinitiv.com/en/financial-data/market-data/tick-history) database tells us that

> Because one cannot distinguish market orders from cancellations just by observing changes in the limit order book (the “event” file), and since, the time stamps of the “trade” and “event” files are asynchronous, we use a matching procedure to reconstruct the order book events.

The reported matching rate of the above procedure is about 85% for CAC 40 stocks and as a byproduct the procedure outputs the sign of each matched trade, that is whether it is a buyer or a seller initiated trade. Note that TRTH data set does not even provide information about trade direction, it has to be deduced!

The description of similar issues we find in [@hautsch_modelling_2004]:

> A typical problem occurs when trades and quotes are recorded in separate trade and quote databases, like, for example, in the Trade and Quote (TAQ) database released by the NYSE. In this case, it is not directly identifiable whether a quote which has been posted some seconds before a transaction was already valid at the corresponding trade.

[Websocket API v2](https://www.bitstamp.net/websocket/v2/) of the cryptocurrency exchange Bitstamp gives access to the following information for every instrument traded:

 * **Live ticker** channel - information about trades. Unique ids of participating limit and market order are provided for every trade,
 * **Live orders** channel - information about limit and market orders (all order creation, change and deletion events are reported).

As we will see later, events in these channels are not always sent in correct order. Sometimes some events appears to be omitted. Time stamps in Live tickers and Live orders channels are not synchronized: market order, changes of limit orders and of market order itself caused by the execution of the market order, trades produced - all may have different time stamps. Substantial amount of orders which appears to be matched are not executed due to [self-trade prevention](https://www.reddit.com/r/Bitstamp/comments/bbvut2/bitstamp_api_behaviour/?utm_source=share&utm_medium=web2x) policy of Bitstamp.
 

Similarly [Websocket API version 2.0]() of the cryptocurrency exchange Bitfinex have the following channels (for every instrument traded):

 * **Trades** channel - information about trades. Ids of participating limit and market orders are not provided,
 * **Raw book** channel - provides information about 100 best bid and 100 ask limit orders. Market orders are not reported at all. A limit order is reported as deleted when it falls beyond 100+ best limit orders and as re-created (i.e. with the same id) if it returns back. What happens to the order after it has fallen beyond 100+ is not known: Bitfinex allows traders to change the price and volume of submitted limit order, so the order can be changed, cancelled or stay unchanged. 
 
As well as at Bitstamp, records in Trades and Raw book channels are not synchronized.

It should be clear from the above that substantial effort is required to reconstruct the true dynamics of order submission, matching and execution.

# Methods

We defined the terms "order event and "reconstruction" strictly, developed a software that reconstructs order events in accordance with these definitions from data provided by several cryptocurrency exchanges and analysed whether the exchanges provide enough information for the comprehensive reconstruction of their order book evolution.

Surprisingly, an order, an order event, a limit order book,  the operations of a continuous double auction are rather complicated things if one attempts to define them rigorously. Consider, for example,  a definition given in the book [@bouchaud_trades_2018]:


> An order is a commitment, declared at a given submission time, to buy or sell a given volume of an asset at no worse than a given price. An order $x$ is thus described by four attributes:
>
> * its sign (or direction) $\epsilon = \pm 1$, ($\epsilon_x = +1$ for buy orders; $\epsilon_x = −1$ for sell orders),
  * its price $p_x$ ,
  * its volume $v_x > 0$, and
  * its submission time $t_x$.
>  
> We introduce the succinct notation $x := (\epsilon_x , p_x ,v_x, t_x )$.

[@bouchaud_trades_2018] then continues with a description of what they call The Trade-Matching Algorithm:

> Whenever a trader submits a buy (respectively, sell) order $x$, an LOB’s *trade-matching algorithm* checks whether it is possible for $x$ to match to existing sell (respectively,buy)orders $y$ such that $p_y \leq p_x$ (respectively, $p_y \geq p_x$). If so, the matching occurs immediately and the relevant traders perform a trade for the agreed amount at the agreed price. Any portion of $x$ that does not match instead becomes active at the price $p_x$, and it remains active until either it matches to an incoming sell (respectively, buy) order or it is cancelled. Cancellation usually occurs when the owner of an order no longer wishes to offer a trade at the stated price.

The above definition and description are incomplete:

* According to the definition, an order $x$ seems to be an immutable entity. But according to the Trade-Matching algorithm, a portion of $x$ may become 'active' and it is not clear how the quality of being 'active' is different from the mere existence of submitted orders,

* At what price the trade is performed - $p_x$ or $p_y$ - is not explicitly stated,

* It is not stated what will happen if $v_x \leq v_y$, etc. 

Below we propose stricter definitions that address these and the other similar issues trying to stay close to [@bouchaud_trades_2018]. Afterwards we describe the reconstruction process.

## Definitions 

### Order event

```{definition Order Function, name="Order Function", label="order" }

A function $o : \mathbb{R}_{>0} \times \mathbb{R} \mapsto \mathbb{R}$ is called a limit *order function* if it can be written as 
$$ 
  o(p,t) = \sum_{k=1}^K v_k \mathbf{1}_{P_k \times T_k}(p,t)
$$
where  

   a. $\mathcal{T} = \{T_k\}_{k=1}^{K}$ is a partition of left-open finite or right-unbounded interval of $\mathbb{R}$ into intervals with endpoints $t_{k,1} \in \mathbb{R}$, $t_{k,2} \in \mathbb{R} \cup \{+\infty\}$ such that:
       1. $\forall k \leq K : t_{k,1},t_{k,2} \in \{n \tau : n \in \mathbb{Z}\}$, where $\tau \in \mathbb{R}_{>0}$ is a constant called *sampling interval* 
       2. $\forall k < K : t_{k,1} \leq t_{k+1,1} \land t_{k,2} < t_{k+1,2}$
 
 
 a. $\mathcal{P} = \{P_k\}_{k=1}^{K}$ is a set of degenerate intervals $P_k = \{p_k\}$ with endpoints $p_k \in \mathbb{R}_{> 0}$, such that:
     1. $\forall k: p_k \in \{ n \pi : n \in \mathbb{N} \}$ where $\pi \in \mathbb{R}_{>0}$ is a constant called *quote increment* or *tick size*,
     2. $\forall k < K$ if $t_{k,2} \not \in T_k$ then $p_{k+1} = p_k$
     
 a. $\mathcal{V} = \{v_k \}_{k=1}^K$ is a set of constants $v_k \in \mathbb{R}_{\neq 0}$ called *order volumes* such that:
     1. $\forall k$ either $v_k \in \mathbb{R}_{> 0}$ (buy order) or $v_k \in \mathbb{R}_{< 0}$ (sell order),
     2. $|v_k| \in \{ n \phi : n \in \mathbb{N}\}$  where $\phi \in \mathbb{R}_{>0}$ is a constant called *base increment* or *lot size*, 
 
 a. $\mathbf{1}_{P_k \times T_k}(p, t)$ is an indicator function of the set ${P_k \times T_k}$: 
$$
\mathbf{1}_{P_k \times T_k}(p,t) = \begin{cases} 1, & (p,t) \in P_k \times T_k \\ 0, & (p,t) \not \in P_k \times T_k  \end{cases}
$$
```

The sample interval $\tau$, quote increment $\pi$ and base increment $\phi$ are collectively called *resolution parameters*.



```{definition Price Function, name="Price Function", label="price-function"}
Suppose an order function $o(p,t)$ as defined by \@ref(def:order) is given. A function of time $$p(t) \equiv \arg\!\max_p |o(p,t)|$$
is called a *price function*.
```



```{definition Volume Function, name="Volume Function", label="volume-function"}
Suppose an order function $o(p,t)$ as defined by \@ref(def:order) and related price function $p(t)$ as defined by \@ref(def:price-function) are given. A function of time $$v(t) \equiv o(p(t),t)$$ is called a *volume function*.
```


```{definition Filled Volume, name="Filled Volume", label=filled-volume}
Suppose a volume function $v(t)$ as defined by \@ref(def:volume-function) is given. The function 
  $$
  f_{v}(t) = v(t) - \lim_{t^{'} \uparrow t} v(t^{'}) 
  $$ is called a *filled volume* at time $t$.  

```

$f_{v}(t) \neq 0$ implies that there is a right-open interval $T_k$ such that its right endpoint equals to $t$. 

```{definition Amended Volume, name="Amended Volume", label=amended-volume}
Suppose a volume function $v(t)$ as defined by \@ref(def:volume-function) is given. The function 
  $$
  a_{v}(t) = \lim_{t^{'} \downarrow t} v(t^{'}) - v(t)
$$ is called an *amended* volume at time $t$.

```

It follows from definition \@ref(def:order) that $T_1$ is left-open, so $a_v(t_{1,1}) = v_1 \neq 0$. This is the only place where we follow [@bouchaud_trades_2018] by modelling order placement as càglàd (continue à gauche, limite à droite) process:

> ... we will consider the evolution of an LOB $\mathcal{L}(t)$ as a so-called *càglàd process (continu à gauche, limite à droite)*. Informally, this means that when a new order $x$ is submitted at time $t_x$ , we regard it to be present in the LOB immediately after its arrival, but not immediately upon its arrival.

Then $a_v(t) \neq 0$ at some point $t_{1,1} < t < t_{K,2}$ implies that there is a left-open interval $T_k$ such that its left endpoint equals to $t$.

Finally $a_{v}(t_{K,2}) \neq 0$ implies that $T_K$ is a right-closed, possibly degenerate, interval.

An order can be conveniently represented in the form of a order table defined by \@ref(def:order-table).

```{definition Order Event, name="Order Event", label=order-event}

An *order event* is a tuple $(t,s,p,v,m)$ where

a. $t \in \mathbb{R}$ is an *event timestamp*
b. $s \in \{0, 1\}$ is the *state* of the order after the event; $s = 1$ means the order is active; $s = 0$ means that order is done (finished) i.e. removed from an order book,
b. $p \in \mathbb{R}_{>0}$ is the *order price*,
b. $v \in \mathbb{R}$ is the *order volume*,
b. $m \in \{0,1\}$ is a *match indicator*; $m =1$ means that the order has been *matched* with another one and a trade has occurred between them so the event has been originated by the trade; $m = 0$ means that the event is an amendment and has not been originated by a trade.
```


```{definition Order Table, name="Order Table", label=order-table}
Suppose an order function $o(p,t)$ as defined by \@ref(def:order) is given. A set $$\mathcal{E} = \{(t_k',s_k',p_k',v_k', m_k')\}_k$$ of $K$ or $K+1$ order events 

  a. $\forall k \in \{1, \ldots, K\}$ $k$'s order event is defined as follows:
      1. $t_k' = t_{k,1}, s_k' = 1, p_k' = p_k, v_k' = v_k$,
      2. if $t_{k,1} \in T_k$ then $m_k' = 1$, otherwise $m_k' = 0$,
  a. if $T_K$ is a finite interval, then $K+1$'s order event is defined as follows:
  
      1. $t_{K+1}' = t_{K,2}, s_{K+1}' = 0, p_{K+1}'=p_K$,
      2. if $t_{K,2} \not \in T_K$ then $m_{K+1} = 1$,$v_{K+1}' = 0$;  otherwise $m_{K+1}' = 0$, $v_{K+1}' = v_k$ 
             
is called *an order table*. The index $k$ is called *an event ordinal number*.

```



```{theorem Order Table Equivalence,label=equivalence}
An order function \@ref(def:order) can be unambiguously restored from its order table \@ref(def:order-table).
```

```{proof}
Suppose the order table $\mathcal{E} = \{(t_k',s_k',p_k',v_k', m_k')\}_{k=1}^{R}$ is given. To restore the corresponding order function $o(p,t)$ as defined by \@ref(def:order) we need to restore $\mathcal{T}$, $\mathcal{P}$ and $\mathcal{V}$ sets. It can be done as follows:

1. For all $1 \leq k < R$ 

    a. The interval $T_k$ with left endpoint $t_k'$ and right endpoint $t_{k+1}'$ which is:
  
        * a left-open if $m_k'=0$ and left-closed if $m_k'=1$
        * a right-open if $m_{k+1}'=1$ and right-closed if $m_{k+1}'=0$
      
       is added to $\mathcal{T}$
      
    a. The interval $P_k = \{p_k'\}$ is added to $\mathcal{P}$
    a. The constant $v_k'$ is added to $\mathcal{V}$

    
2. If $s_R' = 1$:
    a. The interval $T_R$ which is either $(t_R', +\infty)$ if $m_R'=0$ or $[t_{R}', +\infty)$ if $m_R'=1$ is added to $\mathcal{T}$,
    a. The interval $P_R = \{p_R\}$ is added to $\mathcal{P}$,
    a. The constant $v_R'$ is added to $\mathcal{V}$; note that $v_R' \neq 0$.

```

Note that $|\mathcal{E}| = |\mathcal{T}| + 1$ if the last interval $T_k$ is finite and $|\mathcal{E}| = |\mathcal{T}|$ otherwise, as in definition \@ref(def:order-table).

See [Appendix][Examples of order tables and restored functions] for examples of order tables and order functions restored from them.


Typically the term [order book](https://www.investopedia.com/terms/o/order-book.asp) refers to an electronic list of buy and sell orders for a specific security or financial instrument organized by price level. An order book lists the number of shares being bid on or offered at each price point, or market depth. Order books are used by almost every exchange to list the orders for different securities. 


```{definition Order Set, name="Order Set", label=order-set}
A set of orders with common resolution parameters $\tau$, $\pi$ and $\phi$ $$\mathcal{O} = \{o^i(\cdot, \cdot)\}_i$$ where $o^i(\cdot, \cdot)$ is defined by \@ref(def:order) is called an *order set*.
```


```{definition Bids, name="Bids", label=bids}
Suppose an order set $\mathcal{O}$ as defined by \@ref(def:order-set) is given. A (possibly empty) subset $\mathcal{B} =\{o^b(\cdot, \cdot)\}_{v^b(\cdot) \geq 0} \subset \mathcal{O}$ of buy orders is called *bids*.  A (possibly empty) subset of *bids* $\mathcal{B}(t) =\{o^b(\cdot,\cdot)\}_{v^b(t) \geq 0 \land p^b(t) > 0} \subset \mathcal{B}$ of buy orders is called *bids* at time $t$.
```

```{definition Asks, name="Asks", label=asks}
Suppose an order set $\mathcal{O}$ as defined by \@ref(def:order-set) is given. A (possibly empty) subset $\mathcal{A} =\{o^a(\cdot, \cdot)\}_{v^a(\cdot) \leq 0} \subset \mathcal{O}$ of sell orders is called *asks*. A (possibly empty) subset of *asks* $\mathcal{A}(t) =\{o^a(\cdot,\cdot)\}_{v^a(t) \leq 0 \land p^a(t) > 0} \subset \mathcal{A}$ of sell orders is called *asks* at time $t$.
```

From definition of an order \@ref(def:order) follows that $\mathcal{O} = \mathcal{A} \cup \mathcal{B}$ and $\mathcal{A} \cap \mathcal{B} = \emptyset$.


```{definition Best Bid Price, name="Best Bid Price", label=best-bid-price}
Suppose an order set $\mathcal{O}$ is given.  The function $b(t)$ defined as:
  $$
  b_{\mathcal{O}}(t) = \begin{cases} \max_{o^b(\cdot,\cdot) \in \mathcal{B}(t)} p^b(t), & \text{ if } \mathcal{B}(t) \neq \emptyset \\0, & \text{ otherwise }  \end{cases}
  $$ is called *best bid price*.
```


```{definition Best Ask Price, name="Best Ask Price", label=best-ask-price}
Suppose an order set $\mathcal{O}$ is given. The function $a(t)$ defined as:
  $$
  a_{\mathcal{O}}(t) = \begin{cases} \min_{o^a(\cdot,\cdot) \in \mathcal{A}(t)} p^a(t) & \text{ if } \mathcal{A}(t) \neq \emptyset \\ +\infty, & \text{ otherwise } \end{cases}
  $$ is called *best ask price*
```


```{definition Spread, name="Spread", label=spread}
Suppose an order set $\mathcal{O}$ is given and $a_{\mathcal{O}}(t)$ and $b_{\mathcal{O}}(t)$ are its best ask price and best bid price functions as defined by \@ref(def:best-ask-price) and \@ref(def:best-bid-price) respectively. Then the function $$
  s_{\mathcal{O}}(t) = a_{\mathcal{O}}(t) -  b_{\mathcal{O}}(t) 
  $$ is called *spread*.
```


```{definition Limit Order Book, name="Limit Order Book", label=lob}
Suppose an order set $\mathcal{L}$ as defined by \@ref(def:order-set) is given.  Then $\mathcal{L}$ is called a *Limit Order Book (LOB)* if its spread function as defined by \@ref(def:spread) is always positive:
$$ 
  \forall t: s_{\mathcal{L}}(t) > 0
$$
```



A [market order](https://www.investopedia.com/terms/m/marketorder.asp) is a request by an investor to buy or sell a security at the best available price at the time of order placement. The request is usually made through a broker or brokerage service and is ultimately executed by an exchange that maintains an order book.  Clearly, a market order cause an exchange's order book to be updated so market orders are modeled as *changes* of an order book. 


```{definition Market Buy Order, name="Market Buy Order", label=market-buy-order}
Suppose a Limit Order Book $\mathcal{L}$ is given as defined by \@ref(def:lob). Suppose that at time $t_j$ $$\sum_{o^a(\cdot, \cdot) \in \mathcal{A(t_j)} } f_{v^a}(t_j) < 0 $$ Then it is said that a *market buy order* is placed and executed at time $t_j$ for $\sum_{o^a(\cdot, \cdot) \in \mathcal{A}(t_j) } |f_{v^a}(t_j)p^a(t_j)|$ units of currency.  

```


```{definition Market Sell Order, name="Market Sell Order", label=market-sell-order}
Suppose a Limit Order Book $\mathcal{L}$ is given as defined by \@ref(def:lob). Suppose that at time $t_j$ $$\sum_{o^b(\cdot, \cdot) \in \mathcal{B}(t_j) } f_{v^b}(t_j) > 0 $$ Then it is said that a *market sell order* is placed and executed at time $t_j$ for $\sum_{o^b(\cdot, \cdot) \in \mathcal{B}(t_j) } f_{v^b}(t_j)$ units of asset.  

```

To make the above definitions intuitively clear, consider an example in [Appendix][Example of LOB].


```{definition Order Set Table, name="Order Set Table", label=order-set-table}
Suppose an order set $\mathcal{O} = \{ o^i(\cdot, \cdot) \}_i$ as defined by \@ref(def:order-set) is given. A union of set of tuples:
$$\mathcal{S} = \bigcup_i \big\{(i, k, t_k^i, s_k^i,p_k^i, v_k^i, m_k^i)\big\}_{k=1}^{K^i}$$ where $i$ is *a unique order identification number* and $\{(t_k^i, s_k^i,p_k^i, v_k^i, m_k^i)\}_{k=1}^{K^i}$ is the order table as defined by \@ref(def:order-table) of order $o^i(\cdot, \cdot)$ is called *an order set table*. Each tuple in the order set table is called *an order event with order id*.
```

### Stripe and Dot

```{r transmute-example-1, echo=FALSE}
dt <- fread(file = "transmute_example_1.csv")[,c("maker","ordinal","timestamp","mks","state","price","volume","trade")]
setnafill(dt, type="locf", cols=3)
setnafill(dt, type="const", fill=0, cols=c(4, 5,7,8))
as_hux(dt[ , .(`\\(i\\)`=maker, `\\(k\\)`=ordinal, `\\(t^i_k\\)`=timestamp+mks/1000000.0,
               `\\(s^i_k\\)`=state, `\\(p^i_k\\)`=price, `\\(v^i_k\\)`=volume, `\\(m^i_k\\)`=as.integer(trade != 0) )]) %>%  set_caption("In spite of being very short Order Set Table shown is hard to understand")
```


```{bash gnuplot-code-1, echo=FALSE}
gnuplot -p <<-EOF
  set xdata time
  set timefmt "%Y-%m-%dT%H:%M:%SZ"
  set xtics format "%M:%.1S" rotate by 45
  set xrange ["2021-03-26T13:59:05.9Z":"2021-03-26T13:59:07.3Z"]
  set yrange [525:545]
  set datafile separator comma
  set palette defined (-1 "blue", 0 'white', 1 'red')
  set cbrange [-1:1]
  set term png
  set output "transmute_example_1.png"
  set grid
  set pointsize 2
  val(name) = stringcolumn(name) ne "" ? column(name) : 0
  tval(t)=stringcolumn("timestamp") ne ""? strptime("%Y-%m-%dT%H:%M:%SZ",stringcolumn("timestamp")):t
  t=""
  plot \
    "transmute_example_1.csv" using \
      ((t=tval(t),t+val("mks")/1000000.0)):\
      (column("price")):\
      (-val("timestamp_change")/1000000.0):\
      (0):\
      (val("volume") - val("volume_change")) with vectors lc palette z nohead notitle,\
    '' using\
      ((t=tval(t),t+val("mks")/1000000.0)):\
      (column("trade") > 0 ? column("price"): 1/0):(column("volume_change")) with points lc palette z pointtype 7 notitle
EOF

```



```{r transmute-example-1-picture, echo=FALSE, fig.cap="It is easier to comprehend a visual representation of Order Set Table \\@ref(tab:transmute-example-1)", fig.align="center"}
knitr::include_graphics("transmute_example_1.png", dpi=80)
```


```{r transmute-example-2, echo=FALSE}
dt <- fread(file = "transmute_example_2.csv")[,c("maker","ordinal","timestamp","mks","state","price","volume","trade")]
setnafill(dt, type="locf", cols=3)
setnafill(dt, type="const", fill=0, cols=c(4, 5,7,8))
as_hux(dt[ , .(`\\(i\\)`=maker, `\\(k\\)`=ordinal, `\\(t^i_k\\)`=timestamp+mks/1000000.0,
               `\\(s^i_k\\)`=state, `\\(p^i_k\\)`=price, `\\(v^i_k\\)`=volume, `\\(m^i_k\\)`=as.integer(trade != 0) )]) %>%
  set_background_color(c(5,10), everywhere, "grey") %>%
  set_caption("Order 4 with two events has been added to Order Set Table")

```


```{bash gnuplot-code-2, echo=FALSE}
gnuplot -p <<-EOF
  set xdata time
  set timefmt "%Y-%m-%dT%H:%M:%SZ"
  set xtics format "%M:%.1S" rotate by 45
  set xrange ["2021-03-26T13:59:05.9Z":"2021-03-26T13:59:07.3Z"]
  set yrange [525:545]
  set datafile separator comma
  set palette defined (-1 "blue", 0 'white', 1 'red')
  set cbrange [-1:1]
  set term png
  set output "transmute_example_2.png"
  set grid
  set pointsize 2
  val(name) = stringcolumn(name) ne "" ? column(name) : 0
  tval(t)=stringcolumn("timestamp") ne ""? strptime("%Y-%m-%dT%H:%M:%SZ",stringcolumn("timestamp")):t
  t=""
  plot \
    "transmute_example_2.csv" using \
      ((t=tval(t),t+val("mks")/1000000.0)):\
      (column("price")):\
      (-val("timestamp_change")/1000000.0):\
      (0):\
      (val("volume") - val("volume_change")) with vectors lc palette z nohead notitle,\
    '' using\
      ((t=tval(t),t+val("mks")/1000000.0)):\
      (column("trade") > 0 ? column("price"): 1/0):(column("volume_change")) with points lc palette z pointtype 7 notitle
EOF

```

```{r transmute-example-2-picture, echo=FALSE, fig.cap="A visual representation of Order Book Set \\@ref(tab:transmute-example-2) is distorted since orders 3 and 4 overlaps", fig.align="center"}
knitr::include_graphics("transmute_example_2.png", dpi=80)
```
## Software 



### Capture order events


Figure \@ref(fig:capture-overview) shows UML2 Activity Diagram [@cook_omg_2017] of `S.1 Capture` activity that represents an implementation of `oberon capture` command. The activity node `Reconstruct Order Book` performs a reconstruction of order book events from exchange-specific messages that are passed by node `Receive messages`.


```{r capture-overview, echo=FALSE, fig.cap="`Receive messages` activity node collects avaialbe information in an exchange-specific format and pass the information in the form of [Boost.Property Tree](https://www.boost.org/doc/libs/1_73_0/doc/html/property_tree.html) to `Reconstruct Order Book` activity node that, as its name implies, reconstructs order book events in an *universal* format described herein. Note that both activity nodes run concurrently.", fig.align="left"}
knitr::include_graphics("Standalone application - capture.png", dpi=80)
```

#### Receive messages

Activity `Receive messages` on figure \@ref(fig:capture-overview) is UML2 `StartObjectBehaviourAction` that starts execution of `Receiver` StateMachine shown on figure \@ref(fig:receiver). The call is synchronous, so the execution of the `Receive messages` does not complete until the execution of `Receiver` StateMachine completes.

(ref:receiver-caption) `Processing snapshot` and `Processing messages` states pass received portions of data to `Reconstruct Order Book` (by calling method `Reconstructor::process()` shown on figure \@ref(fig:sd-reconstructor-process)) thereby the streaming of data between `Receive messages` and `Reconstruct Order Book` on figure \@ref(fig:capture-overview) is implemented.

```{r receiver, echo=FALSE, fig.cap="(ref:receiver-caption)", fig.align="left"}
knitr::include_graphics("Receiver state machine.png", dpi=80)
```

Almost all exchanges  provide two separate channels for receiving (i) a list of orders currently open on order book and (ii) order updates. In order to capture a dynamics of an order book one need to receive information from both channels and combine it. `Feeder` StateMachine shown on figure \@ref(fig:feeder) deals with receiving order updates while `Snapshot` StateMachine shown on figure \@ref(fig:snapshot) is responsible for getting a list of orders currently open on order book.

Now look at figure \@ref(fig:receiver) again. An entry behaviour of `Engage.Engaging Feeder` state launches `Feeder` StateMachine asynchronously. The latter sends "success" event as soon as it successfully subscribed for order updates and `Receiver` transitions to `Engage.Feeder Engaged.Making Snapshot.Obtaining` state. The state's entry behaviour asynchronously launches `Snapshot` StateMachine shown on figure \@ref(fig:snapshot). 

While `Receiver` remains in `Engaged.Feeder Engaged.Making Snapshot` state messages sent by `Feeder` are queued by internal transition activity on `Receiver.Feeder Engaged` state.  As soon as `Snapshot` has received the snapshot, it sends `Receiver` "success" event and `Receiver` checks whether the snapshot and messages from `Feeder` cover the intersecting time periods or the snapshot is stale. In the latter case the snapshot is re-queried. Otherwise `Receiver` transitions to `Processing snapshot` state which asynchronously passes the snapshot to `Reconstruct Order Book` activity and upon receiveing "success" event transitions to `Processing messages` which asynchronously passes  messages received from an exchange to `Reconstruct Order Book`. It is assumed that `Receiver` spends most of the time in this state.

(ref:feeder-caption) Transition `success` between `Subscribe` and `Receive` states sends "success" event to `Receiver` StateMachine. An entry behaviour of `Receive` state launches asynchronous read operation, whose successfull completion triggers  `success` transition from `Receive`. If some service message (i.e. heartbeat, subscription) has arrived, it is processed locally. Otherwise "message" event is sent to `Receiver`.

```{r feeder, echo=FALSE, fig.cap="(ref:feeder-caption)", fig.align="left"}
knitr::include_graphics("Feeder state machine.png", dpi=80)
```

(ref:snapshot-caption) Snapshot StateMachine diagram.

```{r snapshot, echo=FALSE, fig.cap="(ref:snapshot-caption)", fig.align="left"}
knitr::include_graphics("Snapshot state machine.png", dpi=80)
```
#### Reconstruct Order Book

Figure \@ref(fig:reconstruct-order-book) shows UML2 Activity Diagram of `Reconstruct Order Book` activity which is called by the activity node with the same name on figure \@ref(fig:capture-overview).


```{r reconstruct-order-book, echo=FALSE, fig.cap="`Reconstruct Order Book` activity is implemented by an indefinite loop that invokes `Process message` activity every time new instance is placed on its input pin `ptree`. The loop terminates if `Process message` throws `processing_error` exception.", fig.align="left"}
knitr::include_graphics("Reconstruct Order Book.png", dpi=80)
```
The activity node `Process message` on figure \@ref(fig:reconstruct-order-book) is Call Action. It calls method `Reconstructor::process()` on `target` instance. UML2 Sequence diagram on figure \@ref(fig:sd-reconstructor-process) shows a "happy path" trace of the method.

```{r sd-reconstructor-process, echo=FALSE, fig.cap="`Reconstructor::process()` first calls virtual abstract `extract()` method to create an instance of a class derived from `Message`. The `extract()` method is abstract and overriden by an exchange-specific implementation class, derived from `Reconstructor`. The returned instance is passed to a chain of `TokenHandler`'s through the call of `handle()`", fig.align="left"}
knitr::include_graphics("sd Reconstructor - process.png", dpi=80)
```

The virtual method `Reconstructor::extract()` takes a [Boost.PropertyTree](https://www.boost.org/doc/libs/1_73_0/doc/html/property_tree.html) container with an exchange-specific data and creates an instance of one of internal exchange-independent message class shown in green on figure \@ref(fig:message-hierarchy-process). The message is returned in `Token` container.

```{r message-hierarchy-process, echo=FALSE, fig.cap="`Message`-based hierarchy of classes used in implementation of `Process message` activity. A message of class `Era` carries information about exchange and product being processed.", fig.align="center"}
knitr::include_graphics("Message hierarchy for process.png", dpi=80)
```

As shown on figure \@ref(fig:reconstructor-hierarchy-process) `Reconstructor::extract()` method is *abstract*, so it is overriden by exchange-specific versions that able to process their respective containers properly. 

```{r reconstructor-hierarchy-process, echo=FALSE, fig.cap="\"Reconstructor\" hierarchy of classes used in implementation of \"Process message\" activity.", fig.align="center"}
knitr::include_graphics("Reconstructor hierarchy for process.png", dpi=80)
```

`Token` that carries an instance of a class derived from `Message` is then taken by the `TokenHandle::handle()` (`Reconstructor` is derived from `TokenHandler`) that is the first step of so called *data cleansing*. According to [@rahm_data_2000]:

> *Data cleaning*, also called *data cleansing* or *scrubbing*, deals with detecting and removing errors and inconsistencies from data in order to improve the quality of data.

Data cleansing is implemented using [Chain of Responsibility](https://en.wikipedia.org/wiki/Chain-of-responsibility_pattern) pattern. Each `TokenHandler` accepts, as a constructor parameter, the next `TokenHandler` which will receive messages as soon as `TokenHandler` being constructed has handled them.

UML2 Sequence Diagram of `TokenHandler::handle()` is shown on figure \@ref(fig:sd-tokenhandler-handle). The number of `TokenHandler`s involved and their kinds depend on an exchange and described in details in their respective sections later.


```{r sd-tokenhandler-handle, echo=FALSE, fig.cap="UML2 Sequence diagram showing a \"happy path\" trace of TokenHandler::handle() method", fig.align="center"}
knitr::include_graphics("sd TokenHandler - handle.png", dpi=80)
```

Handling of messages by `TokenHandler` is denoted by interaction use `Message - accept` on figure \@ref(fig:sd-tokenhandler-handle). The result of handling is a set of zero or more messages that are stored in `output_` member variable that is an instance of `Tokens` class shown on figure \@ref(fig:tokens).

```{r tokens, echo=FALSE, fig.cap="Definition of \"Tokens\".", fig.align="center"}
knitr::include_graphics("Tokens.png", dpi=80)
```
`TokenHandler` will not produce output for a message when subsequent messages are required for handling(cleansing). In this case the message will be kept within this particular `TokenHandler` instance between runs of `Reconstructor::process()` until enough subsequent messages are received. Then all kept and cleansed messages are returned together, saved into `output_` variable and passed one by one in FIFO order to the `this.next_` `TokenHandler`. After that `output_` variables is cleared, so if there is no next `TokenHandler` the messages are deleted after being accepted.

Handling of messages by `TokenHandler` is implemented using [Visitor](https://en.wikipedia.org/wiki/Visitor_pattern) pattern as shown by UML2 Sequence diagram on figure \@ref(fig:sd-message-accept).

```{r sd-message-accept, echo=FALSE, fig.cap="UML2 Sequence diagram showing various alternatives of traces for Message::accept() method", fig.align="center"}
knitr::include_graphics("sd Message - accept.png", dpi=80)
```

It should be clear from the definition of order table \@ref(def:order-table) that not every set of order events as defined by \@ref(def:order-event) represents a valid order table. Similarly, not every set of orders represents valid LOB as defined by \@ref(def:lob).

  Data cleansing process receives a stream of order events (possible extended and/or incomplete i.e. order events as defined by \@ref(def:order-event) but with some additional and/or missing attributes), restores order functions from them and then restores LOB from order functions.
  
Data cleansing is performed by a sequence of `TokenHandler`s as shown on figure \@ref(fig:sd-tokenhandler-handle). Table \@ref(tab:tokenhandler-chains) below lists `TokenHandler`s used for different exchange event streams.

```{r tokenhandler-chains, echo=FALSE}
hux(TokenHandler=c("Synchronizer", "TimeOrderEnforcer", "Deduplicator", "SizeDeducer", "EventCounter", "File"),
    Coinbase=c("C", "N", "N", "Y", "Y", "Y"),
    Bitstamp=c("C", "C", "C", "Y", "Y", "Y"),
    Bitfinex=c("N", "C","C", "Y", "Y","Y")) %>%
  set_text_color(1,1, "white") %>%
  set_align(everywhere, 2:4, "center") %>%
  set_caption("Y means that TokenHandler (left) is used by the exchange chain (top), N - is not used and C means that a customized version is used.") %>%
  set_caption_pos("topleft")
```

#### Save output

The last TokenHandler in every chain is `File` that outputs the cleansed events. Upon receving a message of class `Era` (see figure \@ref(fig:message-hierarchy-process)) `File` opens a new file called *Era file* and saves the subsequent `OrderEvent` messages there until obtaining `Reset` message when the handler closes Era file. `File` drops `Elapsed` messages silently.

  Era file is [CSV-file](https://en.wikipedia.org/wiki/Comma-separated_values) with one row per `OrderEvent` and name constructed from  exchange, product and timestamp values carried by `Era` message. Row fields are described in the table \@ref(tab:order-record) below.

```{r order-record, echo=FALSE, results='asis'}
ht <- hux(`#`=seq(1:14),
    Field=c("maker", "ordinal","timestamp", "mks", "timestamp_change", "state", "price", "price_change", "volume", "volume_change", "trade","taker","heard", "deleted" ),
    Type=c("[UUID](https://www.boost.org/doc/libs/1_67_0/libs/uuid/doc/uuid.html#boost/uuid/string_generator.hpp)", "long", "string", "int", "long long", "bool", "double", "double","double", "double", "long long", "UUID", "int", "bool" ),
    Description=c("an unique identification number of the order open on the order book",
                  "A sequential number of the event for this order",
                  "Time the event occurred, in [ISO 8601](https://tools.ietf.org/html/rfc3339#page-10) format, up to a second. Empty field means that the value is the same as in the previous event (previous row)",
                  "Microseconds part of the time the event occurred, if different from zero; otherwise empty",
                  "Microseconds passed since the previous event, i.e. $t_k^i - t_{k-1}^i$ if $k$ is greater than 1 and $t_k^i \\neq t_{k-1}^i$; otherwise empty",
                  "1, if the order is open on the order book after the event; otherwise empty",
                  "Price of the order", 
                  "Price change since the previous event, i.e. $p_k^i - p_{k-1}^i$ if $k$ is greater than 1 and $p_k^i \\neq p_{k-1}^i$; otherwise empty",
                  "Volume of the order if different from zero; otherwise empty",
                  "Change of the order's volume since the previous event, i.e. $v_k^i - v_{k-1}^i$ if $k$ is greater than 1 and $v_k^i \\neq v_{k-1}^i$; otherwise empty",
                  "If the event is originated by a trade it is an unique trade identification number; otherwise emtpy. Thus $m_k^i \\equiv$ trade isn't empty",
                  "If the event is originated by a trade, it is an unique identification number of the matched taker order; otherwise empty",
                  "Microseconds passed since the event occurred on the exchange till the application heard about it, if the event occured on the exchange; otherwise empty",
                  "1, if the event's been deleted (for example, it is a duplicate event); otherwise empty"
            ),
    Element=c("$i$", "$k$", "$t_k^i$", "$t_k^i$", "", "$s_k^i$", "$p_k^i$","",  "$v_k^i$","", "$m_k^i$", "", "", "")
    ) %>%
  set_bold(2:15, 2) %>%
  set_caption("Era file fields and their corresponding elements of order event with order id tuple as defined by \\@ref(def:order-set-table). If the value of a field can not be determined, it is reported as NA. UUIDs may be shorter than 32 hexadecimal digits; in this case it is assumed to be padded by zeros from the left.") %>%
  set_caption_pos("topleft")
print_html(ht)
```


### Slice and merge era files

TBD

### Transmute 

TBD

# Results

## Fragments of extracted events

In the tables below the output of `R.2 Extract` is immediately, i.e. without cleansing, converted to events by `R.4 Save`. 

### Coinbase


```{r Sample Coinbase Extracted Events, eval=TRUE, echo=FALSE}

as_hux(coinbase.extracted[,
                    .(`#`=.I,
                    `\\(i\\)(maker)`=substr(maker_order_id,25, 36), `\\(n\\)`=event_no, `\\(t^i_n\\)`=format(timestamp,format="%H:%M:%OS3"), `\\(s^i_n\\)`=state, `\\(p^i_n\\)`=price, `\\(v^i_n\\)`=volume, `\\(f^i_n\\)`=trade_id, `\\(\\Delta v^i_n \\)`=delta_volume, `taker`=substr(taker_order_id, 25,36) ) ],  scientific=F) %>% add_colnames() %>% set_align(1, c(2,4,5,10), 'center') %>% set_align(everywhere, c(1,3, 6:9), 'right') %>% set_number_format(row=everywhere, col=6:7,value="%.2f") %>% set_number_format(row=everywhere, col=9,value="%.3f") %>% set_left_border(everywhere,9, 1) %>% set_right_border(everywhere,1, 1) %>% set_na_string(everywhere, everywhere, "NA") %>% set_caption('(#tab:stamp-quote-frag) A fragment of ETHUSD stream extracted from data generated by Coinbase during 1 second. Coinbase sends correct data and cleansing is not needed.') %>%
  set_caption_pos("topleft")
  
```


### Bitstamp


```{r bitstamp-hux-output, include=FALSE}


as_hux_event_table <- function(data, capt, rows.to.show = NULL) {
  if (is.null(rows.to.show))
    rows.to.show <- seq(1, nrow(data))
  as_hux(data[,
              .(
                `#` = .I,
                `\\(i\\)(maker)` = substr(maker_order_id, 25, 36),
                `\\(n\\)` = event_no,
                `\\(t^i_n\\)` = format(timestamp, format = "%H:%M:%OS3"),
                `\\(s^i_n\\)` = state,
                `\\(p^i_n\\)` = price,
                `\\(v^i_n\\)` = volume,
                `\\(f^i_n\\)` = trade_id,
                `\\(\\Delta v^i_n \\)` = delta_volume,
                `taker` = substr(taker_order_id, 25, 36)
              )][rows.to.show,],
         scientific = F) %>%
    add_colnames() %>%
    set_align(1, c(2, 4, 5, 10), 'center') %>%
    set_align(everywhere, c(1, 3, 6:9), 'right') %>%
    set_number_format(row = everywhere,
                      col = 6:7,
                      value = "%.2f") %>%
    set_number_format(row = everywhere, col = 9, value = "%.3f") %>%
    set_left_border(everywhere, 9, 1) %>%
    set_right_border(everywhere, 1, 1) %>%
    set_na_string(everywhere, everywhere, "NA") %>%
    set_caption(capt) %>%
    set_caption_pos("topleft")
}

```


```{r Sample Bitstamp Extracted Events, eval=TRUE, echo=FALSE}
as_hux_event_table(bitstamp.extracted,'(#tab:stamp-quote-frag) A fragment of ETHUSD stream extracted from data generated by Bitstamp during 1 second. Rows were received in the order shown in the table. This order is sometimes different from the order in which events have happened on the exchange, see, for example, rows 86 and 87. Bitstamp sends duplicate events and correct class of a received event can not always be determined immediately, so cleansing is required.')
```


### Bitfinex 


Table \@ref(tab:finex-extracted) shows information which can be extracted from data provided by Bitfinex.

The exchange does not provide any information about *market* orders.

Trades are reported by Bitfinex without specifying identification numbers of orders involved (see, for example, line 17). Since Bitfinex trading rules allows a trader to place [Hidden orders](https://support.bitfinex.com/hc/en-us/articles/115003451049-Bitfinex-Order-Types#h_01EDSHX0VBHSX36HFD3A1N3R2E), one may expect to see trades out of the blue since, as it is already said, market orders are not reported and the matched limit order could be a hidden one.

Every ~800 milliseconds Bitfinex sends an update of "200 best LOB orders" set.

The update starts from the list of order identification numbers which have to be removed from "200 best LOB orders" set. The reason of removal is not specified by Bitfinex: the removed order could be cancelled, filled or it could just fall beyound 200 best (see, for example, lines 18-24). Since Bitfinex allows to change the price of a placed order even an order with a last known price that is far from spread may be suddenly filled if the trader who placed the order decides to change the order's price. 

Then update ends by the list of orders to be added to "200 best LOB orders" set. Price and remaining size are provided for each order as well as an order identification number (see lines 25-34). 

```{r Sample Bitfinex Extracted Events, eval=TRUE, echo=FALSE}
as_hux_event_table(bitfinex.extracted,'(#tab:finex-extracted) A fragment of order table which can be extracted from Bitfinex\'s Raw Book and Trades websockets data provided for ETHUSD pair during 1 second. Rows are shown in the order they were received from Bitfinex.' )
```


  
## Fragments of cleansed data


### Bitstamp

```{r Sample Bitstamp Cleansed Events, eval=TRUE, echo=FALSE}
deleted.rows <- which(bitstamp.cleansed$is_deleted) + 1
as_hux_event_table(bitstamp.cleansed,'(#tab:stamp-cleansed-quote-frag) A fragment of ETHUSD stream extracted from data generated by Bitstamp during 1 second. Red rows are deleted by the cleansing step.') %>%
  set_background_color(deleted.rows, col=everywhere, value="red")

```


```{r Bitstamp Cleansed Events Example, eval=TRUE, echo=FALSE}
as_hux_event_table(bitstamp.cleansed,'(#tab:stamp-duplicated) Row 16 is deleted since it is a duplicate of row 12. Rows 14 and 15 are related to the taker order 615591571456 so they are deleted too.', c(12, 14:16))

```



```{r visualise-one-second-changes,eval=FALSE, echo=FALSE, message=FALSE, warning=FALSE, fig.cap="A graphical representation of the evolution of a market depth during 1 second, which is calculated from changing limit orders only. The tick size is $0.01 and sample period is 0.001 second."}

bitstamp.visualise <- bitstamp.cleansed.full[between(timestamp, '2020-03-25 12:17:23+03', '2020-03-25 12:17:24+03') | between(next_timestamp, '2020-03-25 12:17:23+03', '2020-03-25 12:17:24+03') , ][order(timestamp)]
t <- oberon::grid(bitstamp.visualise[(!is_deleted),][order(timestamp)], 139.5,142.5, 0.01,  lubridate::ymd_hms('2020-03-25 12:17:23+03'), lubridate::ymd_hms('2020-03-25 12:17:24+03'),"milli")
small <- 0.0000001
r <- seq(min(t$z)-small, max(t$z), length.out=100)
asks <- c(r[1:(which.max(r >= 0)-1)], -small)
bids <- c(small, r[which.max(r >= 0):length(r)])
col <- c(colorRampPalette(c("blue", "white"))(length(asks)),colorRampPalette(c("white", "red"))(length(bids))[2:length(bids)]) 

layout(matrix(c(2,1), ncol = 2), width=c(1, 4))
image(t,  breaks=c(asks, bids), col=col, axes=F)
x <- as.POSIXct(t$x+0.001, origin="1970-01-01")
x_min <- min(x)
x_max <- max(x)#-as.difftime(0.05, units="secs")


axis.POSIXct(1, at=seq(x_min,x_max, by=as.difftime(0.05, units="secs")), format="%M:%OS2",las=2, lwd=0.1, tck=1)

y_min <- min(t$y)
y_max <- max(t$y)
axis(2, at=seq(y_min, y_max,by=0.2), las=1,lwd=0.1, tck=1)
#par("usr")
plot.new()
levels <- c(asks, bids)
plot.window(xlim = c(0, 1), ylim = rev(range(levels)), xaxs = "i", yaxs = "i")
rect(0, head(levels,-1), 1, tail(levels,-1), col=col, lty="blank")
axis(2)
mtext("Volume", line = 1)


```



```{r visualise-one-second-all, eval=FALSE,echo=FALSE, message=FALSE, warning=FALSE, fig.cap="A graphical representation of the evolution of a market depth during 1 second, which is calculated from all known limit orders. The tick size and sample period are the same as on the previous figure."}
bitstamp.visualise <- bitstamp.cleansed.full[between(timestamp, '2020-03-25 12:17:23+03', '2020-03-25 12:17:24+03') | between(next_timestamp, '2020-03-25 12:17:23+03', '2020-03-25 12:17:24+03') | (timestamp <'2020-03-25 12:17:23+03' & next_timestamp > '2020-03-25 12:17:23+03'), ][order(timestamp)]
t <- oberon::grid(bitstamp.visualise[(!is_deleted),][order(timestamp)], 139.5,142.5, 0.01,  lubridate::ymd_hms('2020-03-25 12:17:23+03'), lubridate::ymd_hms('2020-03-25 12:17:24+03'),"milli")
small <- 0.0000001
r <- seq(min(t$z)-small, max(t$z), length.out=100)
asks <- c(r[1:(which.max(r >= 0)-1)], -small)
bids <- c(small, r[which.max(r >= 0):length(r)])
col <- c(colorRampPalette(c("blue", "white"))(length(asks)),colorRampPalette(c("white", "red"))(length(bids))[2:length(bids)]) 

layout(matrix(c(2,1), ncol = 2), width=c(1, 4))
image(t,  breaks=c(asks, bids), col=col, axes=F)
x <- as.POSIXct(t$x+0.001, origin="1970-01-01")
x_min <- min(x)
x_max <- max(x)#-as.difftime(0.05, units="secs")


axis.POSIXct(1, at=seq(x_min,x_max, by=as.difftime(0.05, units="secs")), format="%M:%OS2",las=2, lwd=0.1, tck=1)

y_min <- min(t$y)
y_max <- max(t$y)
axis(2, at=seq(y_min, y_max,by=0.2), las=1,lwd=0.1, tck=1)
#par("usr")
plot.new()
levels <- c(asks, bids)
plot.window(xlim = c(0, 1), ylim = rev(range(levels)), xaxs = "i", yaxs = "i")
rect(0, head(levels,-1), 1, tail(levels,-1), col=col, lty="blank")
axis(2)
mtext("Volume", line = 1)

```

# Discussion

TBD


# Appendix

## Examples of order tables and restored functions 


```{r Supplementary Functions, include=FALSE}
format_table <- function(events, caption) {
  events[, t:=format(t,"%H:%M:%OS")]
  colnames(events) <- c("$t_k$","$s_k$","$p_k$","$v_k$","$m_k$")
  as_hux(events) %>%
  set_number_format(everywhere, 3, "%.2f") %>%
  set_number_format(everywhere, 4, "%.8f") %>%
  set_caption(caption) %>%
  set_caption_pos("topleft")
}


table2function<- function(events) {
 output <- head(events[, .(T=paste0(fifelse(m == 1, "[", "("), t," , ", shift(t, type="lead"),fifelse(shift(m, type="lead") == 1, ")", "]")), p, v)],-1)
 if(tail(events,1)$s == 1) {
   output <- rbind(output, tail(events,1)[, .(T=paste0(fifelse(m == 1, "[", "("), t," , $+\\infty$)"), p, v)])
 }
 output
}

format_function <- function(table, caption) {
  colnames(table) <- c("$T_k$", "$p_k$", "$v_k$")
  as_hux(table) %>%
    set_align(1, 1, "center") %>%
    set_number_format(everywhere, 2, "%.2f") %>%
    set_number_format(everywhere, 3, "%.8f") %>%
    set_caption(caption) %>%
    set_caption_pos("topleft")
}
```
Let's start from the simplest case possible.

```{r e1-data, include=FALSE}
events <- fread(text =
"t, s, p, v, m
2021-02-08T13:59:59.942000Z,1,43061.10,1.0,0
")
```


```{r e1-table, echo=FALSE, results='asis'}
print_html(format_table(events, "If an order was open on the order book and nothing else has happened with the order since then (i.e. it has not been not matched, amended or cancelled), its order table will contain one order event. By looking at the sign of $v_n$ value one can say that it is a bid order."))
```

```{r e1-function, echo=FALSE, results='asis'}
print_html(format_function(table2function(events), "The order function restored from order table \\@ref(tab:e1-table) will have one left-open right-unbounded interval $T_1$."))
```

The order function defined by \@ref(tab:e1-function) may be written as: $o(p,t) = v_1 \mathbf{1}_{P_1 \times T_1}(p,t)$.

The corresponding filled volume function as defined by \@ref(def:filled-volume) is identically zero: $$f_v(t) \equiv 0$$

The corresponding amended volume function is defined by \@ref(def:amended-volume) is non-zero at just one point: $$a_v({\small \text{`r events$t[1]`}}) = 1.0$$

```{r e2-data, include=FALSE}
events <- fread(text =
"t, s, p, v, m
2021-02-08T13:59:59.941000Z,1,43063.64,-0.46396261,0
2021-02-08T13:59:59.980000Z,0,43063.64,-0.46396261,0
")
```

```{r e2-table, echo=FALSE, results='asis'}
print_html(format_table(events, "If an order was open on the order book and then cancelled, its order table will contain second event that corresponds to the removal of the order from the order book as indicated by $s_k = 0$ in the second row."))
```

```{r e2-function, echo=FALSE, results='asis'}
print_html(format_function(table2function(events), "Similar to the function \\@ref(tab:e1-function) the order function restored from table \\@ref(tab:e2-table) has one interval $T_k$.  But in this case it is left-open and right-closed for the order was removed from order book due to cancellation as shown by $m_k = 0$ in the second row of table \\@ref(tab:e2-table)."))

```

As in the case of table \@ref(tab:e1-function), the order function defined by \@ref(tab:e2-function) may be written as: $o(p,t) = v_1 \mathbf{1}_{P_1 \times T_1}(p,t)$ and the corresponding filled volume as defined by \@ref(def:filled-volume) function is identically zero: $$f_v(t) \equiv 0$$

But the corresponding amended volume function as defined by \@ref(def:amended-volume) is non-zero at two points: 
$$a_v({\small \text{`r events$t[1]`}}) = `r events$v[1]` \\a_v({\small \text{`r events$t[2]`}}) = `r -events$v[2]`$$

Note that since the order is an ask order, the amendment function is negative at `r events$t[1]` and positive at `r events$t[2]`. It would be the other way around for a bid order.

```{r e3-data, include=FALSE}
events <- fread(text =
"t, s, p, v, m
2021-02-08T13:59:59.943000Z,1,43063.64,-2.5,0
2021-02-08T14:00:00.112000Z,1,43063.64,-2.1,1
2021-02-08T14:00:01.115000Z,1,43065,-2.3,0
")
```

```{r e3-table, echo=FALSE, results='asis'}
print_html(format_table(events, "The ask order was matched after it was open on the order book ($m_2 = 1$) and afterwards its price and volume were simultaneously amended ($m_3 = 0$, $s_3=1$)."))
```

```{r e3-function, echo=FALSE, results='asis'}
print_html(format_function(table2function(events), "$T_1$ is right-open since its right bound is determined by a match (second row in table \\@ref(tab:e3-table) with $m_2 = 1$). $T_2$ is a closed since it is started by a match and ended by an amendment (third row in table \\@ref(tab:e3-table))."))

```

The order function defined by \@ref(tab:e3-function) has the form: $o(p,t) = \sum_{k=1}^3 v_k \mathbb{1}_{P_k\times T_k}(p,t)$.

The corresponding filled volume as defined by \@ref(def:filled-volume) is not identically zero in this case:
$$f_v({\small \text{`r events$t[2]`}}) \equiv v({\small \text{`r events$t[2]`}}) - \lim_{t' \uparrow `r events$t[2]`} v(t') = `r events$v[1]` - (`r events$v[2]`) = `r events$v[1] - events$v[2]`$$

The corresponding amended volume function as defined by \@ref(def:amended-volume) is again non-zero at two points: 
$$a_v({\small \text{`r events$t[1]`}}) = `r events$v[1]` \\a_v({\small \text{`r events$t[3]`}}) = `r events$v[3]` - (`r events$v[2]`) = `r events$v[3]-events$v[2]`$$

Note that $p_1 = p_2$ since $t_{1,2} = {\small \text{`r events$t[2]`}} \not \in T_1$ as required by definition of order function \@ref(def:order) but $p_2 \neq p_3$. The latter is acceptable since $t_{2,2} = {\small \text{`r events$t[3]`}} \in T_2$.

```{r e4-data, include=FALSE}
events <- fread(text =
"t, s, p, v, m
2021-02-08T14:02:02Z,1,43060,5,0
2021-02-08T14:02:03,1,43060,2,1
2021-02-08T14:00:03,0,43060,2,0
")
```

```{r e4-table, echo=FALSE, results='asis'}
print_html(format_table(events, "The bid order was matched after it was open on the order book ($m_2 = 1$) and the remaining amount was cancelled ($m_3 = 0$, $s_3=0$) at the same time."))
```

```{r e4-function, echo=FALSE, results='asis'}
print_html(format_function(table2function(events), "$T_2$ is a degenerate interval since it is started by a match (second row in table \\@ref(tab:e4-table)) and ended by a cancellation (third row in table \\@ref(tab:e4-table)) that happened at the same time."))

```

The order function defined by \@ref(tab:e4-function) has the form: $o(p,t) = \sum_{k=1}^2 v_k \mathbb{1}_{P_k\times T_k}(p,t)$.

Note that *both* filled volume function $f_v(t)$ as defined by \@ref(def:filled-volume) and amended volume function $a_v(t)$ as defined by \@ref(def:amended-volume) are non-zero at $t = t_{1,2} = t_{2,1} = t_{2,2} = {\small \text{`r events$t[2]`}}$:
$$f_v({\small \text{`r events$t[2]`}}) = -3.0 \\a_v({\small \text{`r events$t[2]`}}) = -2.0$$

## Example of LOB


 Table \@ref(tab:example-order-table) contains a consolidated order table for six limit orders 

```{r Sample Order Table Data, include=FALSE}
time_0 <- as.POSIXct('2020-04-02 13:59:57', origin='1970-01-01 00:00:00')
sot <- tribble( ~i, ~n,   ~t,   ~f, ~e,   ~p,   ~v,
                1,   1,	  0.3,   0,	 1,	50,	200,
                1,   2,	  3.1,   1,	 0,	50,	200,
                2,   1,	  1.1,   0,	 1,	80,  -200,
                2,   2,	  1.9,   0,	 1,	80,  -100,
                2,   3,	  4.3,   0,	 0,	80,  -100,
                3,   1,	  2.5,   0,	 1,	25,  500,
                3,   2,	  3.1,   2,	 0,	25,  500,
                4,   1,	  3.1,   0,	 1,	25,  -500,
                4,   2,	  5.0,   3,	 0,	25,	-500,
                5,   1,	  3.7,   0,	 1,	50,  -400,
                5,   2,	  5.0,   4,	 1,	50,  -100,
                5,   3,	  5.4,   5,	 0,	50,  -100,
                6,   1,	  4.8,   0,	 1,	10,	500,
                6,   2,	  5.4,   0,	 1,	60,	400,
                6,   3,	  6.0,   6,	 1,	20,	100,)
setDT(sot)
sot[ ,"volume.decrease" := nafill(shift(v,1),fill=0) - nafill(xor(1,xor(e,1)*f)*v,fill=0), by=i]
sot.intervals <- sot[,
                   .(t_1=t,
                     t_2=shift(t, fill=max(sot$t) + 0.4, type="lead"), # infinity is emulated by max(sot$t) + 0.2                            
                     n=n,
                     e,
                     p.p = nafill(shift(p,type="lag"),fill=0),
                     p, 
                     p.v=nafill(shift(v,type="lag"), fill=0), 
                     v,
                     f,
                     volume.decrease),
                   by=i ]
sample.colours <- c('1'='#66bd63', # 'Buy order 1'
             '2'='#f46d43', # 'Sell order 2'
             '3'='#1a9850', # Buy order 3'
             '4'='#d73027', # 'Sell order 4'
             '5'='#a50026', # Sell order 5'
             '6'='#006837' # 'Buy order 6'
             )
sample.labels <- c('1'='Order 1 (buy)',
                                '2'='Order 2 (sell)',
                                '3'='Order 3 (buy)',
                                '4'='Order 4 (sell)',
                                '5'='Order 5 (sell)',
                                '6'='Order 6 (buy)')
```


```{r example-order-table, echo=FALSE}
as_hux(sot[order(t),
           .( `#`=.I,
              `\\(i\\)`=sprintf("%010i", i),
              `\\(n\\)`=n,
              `\\(t^i_n\\)`=format(time_0 + t, "%H:%M:%OS1"),
              `\\(s^i_n\\)`=e,
              `\\(p^i_n\\)`=p,
              `\\(v^i_n\\)`=v,
              `\\(m^i_n\\)`=f,
               `\\(\\Delta v^i_n \\)`=fifelse(v*volume.decrease > 0 & n > 1, volume.decrease, NA_real_)
                 )]) %>%
  set_width(0.9) %>%
  set_align(everywhere, c(1:5), 'center') %>%
  set_align(1, c(6:9), 'right') %>%
  set_right_border(everywhere,3, 1) %>%
  set_left_border(everywhere,9, 1) %>%
  set_caption('The sample order table contains information about six limit orders, four market orders and six trades.') %>%
  set_caption_pos("topleft") %>%
  set_position("left")
```


Figure \@ref(fig:example-order-book) shows price and volume functions for six limit orders in table \@ref(tab:example-order-table).

```{r example-order-book, fig.height= 7, echo=FALSE, fig.cap="Price and Volume functions for the limit orders in table \\@ref(tab:example-order-table)"}
p <- ggplot(mapping=aes(x=t_1, y=p, colour=as.character(i),   group=as.character(i))) + 
  geom_segment(aes(xend=t_2,yend=p),
               sot.intervals[e ==1 ],
               size=2,
               show.legend=F
               ) + 
  geom_point(data=sot.intervals[e==1 & p != p.p], fill="white", size=4, show.legend=F, shape="circle filled") + 
  geom_point(data=rbind(sot.intervals[e==0, .(t_1, p=p, i) ],
                        sot.intervals[e==1 & p != p.p & n > 1, .(t_1, p=p.p, i) ]
  ),
                        fill="white", size=4, show.legend=F, shape="circle") +
  scale_color_manual("", values=sample.colours ) + 
  scale_x_continuous("", breaks=sot$t, minor_breaks=NULL, labels=NULL) +  
  scale_y_continuous("Price", breaks=c(0, unique(sot$p)), minor_breaks=NULL, limits=c(0,80))+
  theme(legend.position = "none") 

v <- ggplot(mapping=aes(x=t, y=v, colour=as.character(i),  group=as.character(i))) + 
  geom_segment(aes(xend=t_2,yend=v),
               sot.intervals[e ==1, .(t = t_1, t_2, v, e, i) ],
               size=2
               ) + 
  geom_point(data=rbind(sot.intervals[e==1 & v != p.v & f == 0,  .(t = t_1, v, e, i) ],
                        sot.intervals[f != 0,.(t = t_1, v=p.v, e, i)]),
             fill="white", size=4, show.legend=F, shape="circle filled") +
  geom_point(data=rbind(sot.intervals[e==0 & f == 0, .(t = t_1,  v, e, i)],
                        sot.intervals[e==1 & v != p.v & f != 0,  .(t = t_1, v, e, i)],
                        sot.intervals[e==1 & v != p.v & f == 0 & n > 1,  .(t = t_1, v=p.v, e, i)]),
             fill="white", size=4, show.legend=F, shape="circle") + 
  scale_color_manual("", 
                       values=sample.colours,
                       labels=sample.labels) +
  scale_y_continuous("Volume", trans="reverse",
                     breaks=c(0, unique(sot$v)),
                     minor_breaks=NULL
                     ) + 
  scale_x_continuous("Time", breaks=sot$t,
                     labels=format(time_0 + sot$t, "%H:%M:%OS1"),
                     minor_breaks=NULL) +
  scale_shape_manual("Interval", values=c("closed"="circle", "open"="circle filled")) +
  theme(legend.position = "bottom", axis.text.x = element_text(angle = 30, hjust=1))
grid.arrange(p,v, heights=c(3,4))

```
It can bee seen from figure \@ref(fig:example-order-book) that:

  * At `r format(time_0 + sort(unique(sot$t))[1], "%H:%M:%OS1")` order 1 to buy 200 units of the asset at price no worse than 50 per unit has been placed,
  * At `r format(time_0 + sort(unique(sot$t))[2], "%H:%M:%OS1")` order 2 to sell 200 units of the asset at price no worse than 80 per unit has been placed,
  * At `r format(time_0 + sort(unique(sot$t))[3], "%H:%M:%OS1")` the volume of order 2 has been amended (reduced by half) by the trader who placed the order,
  * At `r format(time_0 + sort(unique(sot$t))[4], "%H:%M:%OS1")` order 3 to buy 500 units of the asset at price no worse than 25 per unit has been placed,
  * At `r format(time_0 + sort(unique(sot$t))[5], "%H:%M:%OS1")` order 4 to sell 500 units of the asset at price no worse than 25 has been placed. Exactly at the same time, a market order has been placed to sell 700 units of the asset and two  *sell* trades has been  executed: $(\text{`r format(time_0 + sort(unique(sot$tk))[4], "%H:%M:%OS1")`}, 1, 50, 200)$ and $(\text{`r format(time_0 + sort(unique(sot$t))[4], "%H:%M:%OS1")`}, 3, 25, 500)$. Since the market order and order 4 have been placed at exactly the same time, it is very likely that order 4 has actually been placed to sell 1200 units, partially executed and the reminder (i.e. 500 units) has landed in LOB and there were no market order. Nevertheless fundamentally it is still a combination of a market order and a limit order. 
* At `r format(time_0 + sort(unique(sot$t))[6], "%H:%M:%OS1")` order 5 to sell 400 units of the asset at price no worse than 50 per unit has been placed,
* At `r format(time_0 + sort(unique(sot$t))[7], "%H:%M:%OS1")` order 2 has been cancelled,  
* At `r format(time_0 + sort(unique(sot$t))[8], "%H:%M:%OS1")` order 6 to buy 500 units of the asset at price no worse than 10 per unit has been placed,
* At `r format(time_0 + sort(unique(sot$t))[9], "%H:%M:%OS1")` a market order to buy the asset for 27500 units of the currency has been placed and two buy trades have been executed: $(\text{`r format(time_0 + sort(unique(sot$t))[9], "%H:%M:%OS1")`}, 4, 25, -500)$ and $(\text{`r format(time_0 + sort(unique(sot$t))[9], "%H:%M:%OS1")`}, 5, 50, -300)$. Alternatively, it could be a limit order to buy 800 units of the asset at price no worse than 50 that was fully executed. 
* At `r format(time_0 + sort(unique(sot$t))[10], "%H:%M:%OS1")` volume and price of order 6 have been amended. Its volume has been reduced by 100 units of the asset and its price increased to 60. At the same time a market buy order has been placed for 5000 units of the currency and single trade has been executed: $(\text{`r format(time_0 + sort(unique(sot$t))[9], "%H:%M:%OS1")`}, 5, 50, -100)$. Most likely the change of price of order 6 has transformed it to a market limit order which was partially executed and the reminder was placed in the order book again. 
* At `r format(time_0 + sort(unique(sot$t))[11], "%H:%M:%OS1")` a sell market order has been placed, single trade was executed: $(\text{`r format(time_0 + sort(unique(sot$t))[11], "%H:%M:%OS1")`}, 6, 60, 300)$ and, simultaneously, probably as a consequence of the trade, the price of order 6 has been amended from 60 to 20. Note that trade has been executed at price 60.

## Token handlers

### Synchronizer

TBD

### TimeOrderEnforcer

TBD

### Deduplicator

TBD

```{r  redundant-base, echo=FALSE, fig.cap="States of an order while it being processed by an exchange", fig.align="center"}
knitr::include_graphics("redundant0.png", dpi=80)
```

```{r  redundant-variant1, echo=FALSE, fig.cap="States of an order while it being processed by an exchange", fig.align="center"}
knitr::include_graphics("redundant1.png", dpi=80)
```


```{r  redundant-variant2, echo=FALSE, fig.cap="States of an order while it being processed by an exchange", fig.align="center"}
knitr::include_graphics("redundant2.png", dpi=80)
```


# References





```{r Stub vars for sql chunks, include=FALSE, echo=FALSE}
con <- NULL
bitstamp.quotes <- NULL
bitstamp.trades <- NULL
bitfinex.quotes <- NULL
bitfinex.trades <- NULL
coinbase.quotes <- NULL
coinbase.trades <- NULL
coinbase.full <- NULL

```


```{r Create connection to the database, eval=FALSE, echo=FALSE}
conn <- obadiah::connect("192.168.3.5", "5433", dbname = "obadiah-devel", use.cache=F, user="ob-analytics")
con <- conn$con()
```


```{sql sql - bitstamp.quotes, eval=FALSE, echo=FALSE, connection=con, output.var=bitstamp.quotes}
select * from bitstamp.transient_live_orders 
where era between '2020-03-25 11:27:12.829+03' and '2020-03-26 18:50:59.555+03'
order by microtimestamp;


```


```{sql sql - bitstamp.trades, eval=FALSE, echo=FALSE, connection=con, output.var=bitstamp.trades}
select * from bitstamp.transient_live_trades
where trade_timestamp between '2020-03-25 11:27:12.829+03' and '2020-03-26 18:50:59.555+03' order by trade_timestamp

```

```{r add missing order_created event to Bitstamp, eval=FALSE, include=FALSE}
r <- data.table(order_id=1213590606602240, amount=0.28548526, event='order_created', order_type='sell',  datetime=as.POSIXct('2020-03-25 11:27:13', origin="1970-01-01"), microtimestamp=as.POSIXct('2020-03-25 11:27:12.828', origin="1970-01-01"), local_timestamp=as.POSIXct('2020-03-25 11:27:13.054939', origin="1970-01-01"), pair_id=3, price=142, era=as.POSIXct('2020-03-25 11:27:12.828', origin="1970-01-01"))
class(r$order_type) <- "pq_direction"
class(r$event) <- "pq_live_orders_event"
bitstamp.quotes <- rbind(r, bitstamp.quotes)

```


```{sql sql - bitfinex.quotes, eval=FALSE, echo=FALSE, connection=con, output.var=bitfinex.quotes}
select * from bitfinex.transient_raw_book_events
where channel_id = 11230
order by exchange_timestamp

```




```{sql sql - bitfinex.trades, eval=FALSE, echo=FALSE, connection=con, output.var=bitfinex.trades}
select * from bitfinex.transient_trades
where channel_id = 206
order by exchange_timestamp

```



```{sql sql - coinbase.full, eval=FALSE, echo=FALSE, connection=con, output.var=coinbase.full}
select *
from coinbase.full
order by _time, _type
```



```{r Load Bitstamp data, eval=FALSE, echo=FALSE,}
load(file="bitstamp.Rdata")
setDT(bitstamp.trades)
setDT(bitstamp.quotes)
```

```{r Load Bitfinex data, eval=FALSE, echo=FALSE}
load(file="bitfinex.Rdata")
setDT(bitfinex.trades)
setDT(bitfinex.quotes)

```

```{r Load Coinbase data, eval=FALSE, echo=FALSE}
load(file="coinbase.Rdata")
setDT(coinbase.full)
# Interesting seconds
dcast(coinbase.full[`_type` != 'match', .N, by=ceiling_date(`_time`)][coinbase.full[`_type` == 'match', .N, by=.(ceiling_date(`_time`), `_side`)], on="ceiling_date"][order(-(N*i.N))], ceiling_date + N ~ `_side`, value.var="i.N")[!is.na(buy)& !is.na(sell), ][order(ceiling_date)]

```


```{r Prepare oberon.Rdata, eval=FALSE, echo=FALSE,}
coinbase.extracted <- reconstruct("Coinbase", coinbase.full[`_time` <= '2020-04-01 16:51:57',], extract.only=TRUE)[lubridate::ceiling_date(timestamp) == '2020-04-01 16:51:57',]
setDT(bitstamp.quotes)
setDT(bitstamp.trades)
bitstamp.extracted <- reconstruct("Bitstamp", bitstamp.quotes[microtimestamp <= '2020-03-25 12:17:24+03',], bitstamp.trades[trade_timestamp <= '2020-03-25 12:17:24+03',], extract.only = TRUE)[lubridate::ceiling_date(timestamp) == '2020-03-25 12:17:24+03',]
#[timestamp <= '2020-03-25 12:17:24+03' & next_timestamp >= '2020-03-25 12:17:23+03',]
bitstamp.extracted <- bitstamp.extracted[order(local_timestamp)]

output <- reconstruct("Bitstamp", bitstamp.quotes[microtimestamp <= '2020-03-25 12:17:24+03',], bitstamp.trades[trade_timestamp <= '2020-03-25 12:17:24+03',], extract.only = FALSE)


bitstamp.cleansed.full <- reconstruct("Bitstamp", bitstamp.quotes[microtimestamp <= '2020-03-25 12:17:24+03',], bitstamp.trades[trade_timestamp <= '2020-03-25 12:17:24+03',], extract.only = FALSE)
bitstamp.cleansed <- bitstamp.cleansed.full[lubridate::ceiling_date(timestamp) == '2020-03-25 12:17:24+03',][order(local_timestamp)]
setDT(bitfinex.quotes)
setDT(bitfinex.trades)
bitfinex.extracted <- reconstruct("Bitfinex",
                                  bitfinex.quotes[exchange_timestamp <= '2020-03-26 07:01:34+03',],
                                  bitfinex.trades[exchange_timestamp <= '2020-03-26 07:01:34+03'],
                                  extract.only = TRUE)[lubridate::ceiling_date(timestamp) == '2020-03-26 07:01:34+03',] 
save( coinbase.extracted, bitstamp.extracted, bitstamp.cleansed, bitstamp.cleansed.full, bitfinex.extracted, file="oberon.Rdata", compress=TRUE)

```





