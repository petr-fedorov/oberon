class Main
!!!1439494.cpp!!!	main(in argc : int, in argv : char **) : int
boost::log::register_simple_formatter_factory<
    boost::log::trivial::severity_level, char>("Severity");
boost::log::add_common_attributes();
boost::log::add_console_log(
    std::cout, boost::log::keywords::auto_flush = true,
    boost::log::keywords::format = "%TimeStamp% [%Severity%] %Message%");
boost::log::core::get()->set_filter(boost::log::trivial::severity >=
                                    boost::log::trivial::info);
try {
  parseOptions(argc, argv)->createAcquirer()->acquireAndProcess();
  return EXIT_SUCCESS;
} catch (const std::exception &) {
  return EXIT_FAILURE;
}
!!!1760006.cpp!!!	parseOptions(in argc : int, in argv : char **) : Command::Command_UP
namespace po = boost::program_options;


// Variables to hold option values 
std::string quote_increment;
std::string base_increment;
boost::optional<std::string> exchange;
boost::optional<std::string> product;
boost::optional<std::string> command;
bool deleted = false;
bool source = false;
bool help = false;
int pong_wait_time;
int output_delay;
std::vector<std::string> file_names;
int boundary;

po::options_description common_options("Options are"), deleted_option,
    input_options, slice_options, capture_options, command_option, help_options;

help_options.add_options()("help,h", "produce this help message");
common_options.add_options()(
    "quote-increment,q",
    po::value<std::string>(&quote_increment)->default_value("0.01"),
    "specifies the minimum increment for the quote currency "
    "(i.e. USD in BTC-USD)")(
    "base-increment,b",
    po::value<std::string>(&base_increment)->default_value("0.00000001"),
    "specifies the minimum increment for the base currency (i.e. BTC in "
    "BTC-USD)");
deleted_option.add_options()("deleted,d", "output deleted events");
capture_options.add_options()("exchange,e", po::value(&exchange),
                              "specifies the name of the exchange (mandatory)")(
    "product,p", po::value(&product),
    "specifies the exchange-specific code of the product (mandatory)")(
    "pong-wait-time,w", po::value<int>(&pong_wait_time)->default_value(1),
    "specifies the maximum waiting time for the websocket pong response before "
    "re-connecting, secs")("source,s", "output source of captured events")(
    "output-delay,o", po::value<int>(&output_delay)->default_value(0),
    "a delay of output to enforce correct time order of events, seconds");

input_options.add_options()(
    "input,i", po::value<std::vector<std::string>>()->multitoken(),
    "specifies the name(s) of an era file to be read (mandatory)");

slice_options.add_options()("max-duration,m",
                            po::value<int>(&boundary)->default_value(60),
                            "specifies that a new era will be started every "
                            "arg minutes since UNIX epoch");
command_option.add_options()("command", po::value(&command), "");
po::positional_options_description p;
p.add("command", 1);

po::options_description all;
all.add(common_options)
    .add(capture_options)
    .add(input_options)
    .add(deleted_option)
    .add(slice_options)
    .add(help_options)
    .add(command_option);

po::variables_map vm;
po::store(po::command_line_parser(argc, argv).options(all).positional(p).run(),
          vm);
po::notify(vm);

if (vm.count("help"))
  help = true;

if (vm.count("deleted"))
  deleted = true;

if (vm.count("source"))
  source = true;

if (vm.count("input"))
  file_names = std::move(vm["input"].as<std::vector<std::string>>());


if (command) {
  if (*command == "capture") {
    common_options.add(capture_options).add(deleted_option).add(help_options);
    // Check mandatory options
    if ((exchange && product) && !help) {
      if(*exchange == "Coinbase")
        return boost::make_unique<coinbase::Capture>(quote_increment, base_increment,exchange, product, deleted, source, pong_wait_time, output_delay);
      if(*exchange == "Bitstamp")
        return boost::make_unique<bitstamp::Capture>(quote_increment, base_increment,exchange, product, deleted, source, pong_wait_time, output_delay);
    }
    std::cerr << "Usage: oberon capture [options]\n" << common_options;
    throw std::exception();
  } else if (*command == "transmute") {
    common_options.add(input_options).add(help_options);
    if(!file_names.empty() && !help)
      return boost::make_unique<Transmute>(quote_increment, base_increment,
                                           exchange, product, deleted,
                                           file_names, "");
    std::cerr << "Usage: oberon transmute [options]\n" << common_options;
    throw std::exception();
  }
  else if (*command == "slice") {
    common_options.add(input_options)
        .add(deleted_option)
        .add(slice_options)
        .add(help_options);
    if(!file_names.empty() && !help)
      return boost::make_unique<Slice>(quote_increment, base_increment,
                                       exchange, product, deleted, file_names,
                                       ".sliced", boundary);
    std::cerr << "Usage: oberon slice [options]\n" << common_options;
    throw std::exception();
  }
  else if (*command == "merge") {
    common_options.add(input_options).add(deleted_option).add(help_options);
    if(!file_names.empty() && !help)
      return boost::make_unique<Merge>(quote_increment, base_increment,
                                       exchange, product, deleted, file_names, ".merged");
    std::cerr << "Usage: oberon merge [options]\n" << common_options;
    throw std::exception();
  }
}
std::cerr << "Usage: oberon <command> [options]\n"
          << "Commands are:\n capture\n transmute\n slice\n merge\nRun oberon "
             "<command> --help for the list of options per command.\n";
throw std::exception();

