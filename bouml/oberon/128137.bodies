class Processing_snapshot_State
!!!128777.cpp!!!	success(inout stm : Receiver) : void
  {
    for(auto s = stm._current_state; s != this && s; s = s->_upper(stm)) s->_doexit(stm);
    stm._receiver_state._engage_state._feeder_engaged_state._making_snapshot_state._processing_snapshot_state._doexit(stm);
#ifdef VERBOSE_STATE_MACHINE
   BOOST_LOG_TRIVIAL(debug) <<  stm._machine_name << "execute activity of transition success";
#endif
BOOST_LOG_TRIVIAL(info) << stm._machine_name << "Processed the snapshot. Started processing of messages ...";

    stm._set_currentState(stm._receiver_state._engage_state._feeder_engaged_state._processing_messages_state);
#ifdef VERBOSE_STATE_MACHINE
   BOOST_LOG_TRIVIAL(debug) <<  stm._machine_name << "current state is now .Receiver.Engage.Feeder Engaged.Processing messages";
#endif
    stm._receiver_state._engage_state._feeder_engaged_state._processing_messages_state.create(stm);
  }
!!!128905.cpp!!!	create(inout stm : Receiver) : void
	_doentry(stm);
!!!129033.cpp!!!	_doentry(inout stm : Receiver) : void
#ifdef VERBOSE_STATE_MACHINE
   BOOST_LOG_TRIVIAL(debug) <<  stm._machine_name << "execute entry behavior of .Receiver.Engage.Feeder Engaged.Making Snapshot.Processing snapshot";
#endif
auto iter = stm.d_->messages_.begin();
auto snapshot_seq_number = stm.d_->snapshot_tree_->get<long long>("sequence");
for (; iter != stm.d_->messages_.end() &&
       (*iter)->get<long long>("sequence") != snapshot_seq_number;
     stm.d_->messages_.erase(iter++))
  ;
auto era_time = stm.d_->messages_.front() -> get<std::string>("time");
auto product_id = stm.d_->messages_.front() -> get<std::string>("product_id");
auto local_timestamp = stm.d_->messages_.front() -> get<std::string>("local_timestamp");
stm.d_->messages_.erase(stm.d_->messages_.begin());
auto self = stm.shared_from_this();
// Start new era in another thread since it takes a lot of time ...
boost::asio::post(boost::asio::bind_executor(
    *stm.d_->processing_strand_,
    [&stm, era_time, product_id, local_timestamp, self]() {
      stm.d_->stop_thread_.store(false);
      try {
        boost::property_tree::ptree era;
        era.put<std::string>("type", "era");
        era.put<std::string>("time", era_time);
        era.put<std::string>("product_id", product_id);
        era.put<std::string>("local_timestamp", local_timestamp);
        if (!stm.d_->processor_->process(era))
          throw std::logic_error("Couldn't process era message");

        boost::property_tree::ptree order_tree;

        for (auto iter = stm.d_->snapshot_tree_->get_child("bids").begin();
             iter != stm.d_->snapshot_tree_->get_child("bids").end() &&
             !stm.d_->stop_thread_;
             ++iter) {
          order_tree.clear();
          order_tree.put<std::string>("time", era_time);
          order_tree.put<std::string>("product_id", product_id);
          order_tree.put<std::string>("type", "open");
          order_tree.put<std::string>("side", "buy");

          auto iter2 = iter->second.begin();
          order_tree.put<std::string>("price", iter2++->second.get_value<std::string>());
          order_tree.put<std::string>("remaining_size",
                                 iter2++->second.get_value<std::string>());
          order_tree.put<std::string>("order_id",
                                 iter2++->second.get_value<std::string>());
          order_tree.put<std::string>("local_timestamp", local_timestamp);
          if (!stm.d_->processor_->process(order_tree))
            throw std::logic_error("Couldn't process bid message");
        }
        for (auto iter = stm.d_->snapshot_tree_->get_child("asks").begin();
             iter != stm.d_->snapshot_tree_->get_child("asks").end() &&
             !stm.d_->stop_thread_;
             ++iter) {
          order_tree.clear();
          order_tree.put<std::string>("time", era_time);
          order_tree.put<std::string>("product_id", product_id);
          order_tree.put<std::string>("type", "open");
          order_tree.put<std::string>("side", "sell");

          auto iter2 = iter->second.begin();
          order_tree.put<std::string>("price", iter2++->second.get_value<std::string>());
          order_tree.put<std::string>("remaining_size",
                                 iter2++->second.get_value<std::string>());
          order_tree.put<std::string>("order_id",
                                 iter2++->second.get_value<std::string>());
          order_tree.put<std::string>("local_timestamp", local_timestamp);
          if (!stm.d_->processor_->process(order_tree))
            throw std::logic_error("Couldn't process ask message");
        }
        if (!stm.d_->stop_thread_) // We don't care too much about race condition
                               // here
          stm.postEvent(&Receiver::success);
        else
          stm._post([&stm]() {
            stm.d_->error_message_ = "Snapshot saved has been stopped, exiting ...";
            stm.failure();
          });
      } catch (const std::logic_error &e) {
        std::string w{e.what()};
        stm._post([&stm, w]() {
          stm.d_->error_message_ = w;
          stm.stop(); // We can't process received messages, so we stop the
                      // machine
        });
      } catch (const std::exception &e) {
        std::string w{e.what()};
        stm._post([&stm, w]() {
          stm.d_->error_message_ = w;
          stm.failure();
        });

      } catch (...) {
        stm._post([&stm]() {
          stm.d_->error_message_ =
              "Snapshot saved failed due to an exception, exiting ...";
          stm.failure();
        });
      }
    }));
!!!129161.cpp!!!	_doexit(inout stm : Receiver) : void
#ifdef VERBOSE_STATE_MACHINE
   BOOST_LOG_TRIVIAL(debug) <<  stm._machine_name << "execute exit behavior of .Receiver.Engage.Feeder Engaged.Making Snapshot.Processing snapshot";
#endif
stm.d_->stop_thread_.store(true);

!!!129289.cpp!!!	_upper(inout stm : Receiver) : Receiver::AnyState
  return &stm._receiver_state._engage_state._feeder_engaged_state._making_snapshot_state;
