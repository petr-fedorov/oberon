class File
!!!1460486.cpp!!!	name(in exchange : string, in product : string, in era : Message::Timestamp) : string
return exchange + "_" + product + "_" + date::format("%FT%H-%M-%SZ", era);

!!!1072262.cpp!!!	File(in security : OrderEvent::Security_SP, in handle_deleted : bool = false, in source : bool = false)
quote_precision_ = -std::floor(std::log10(security_->quote_increment));
base_precision_ = -std::floor(std::log10(security_->base_increment));
!!!1072134.cpp!!!	~File()
f_.close();
s_.close();
!!!1072390.cpp!!!	orderEvent() : bool
using namespace oberon::reconstructor;
using boost::uuids::to_string;
using std::chrono::duration;
using std::chrono::duration_cast;
std::stringstream buffer;

OrderEvent *event = static_cast<OrderEvent *>(received_.get());

if (event) {

  // maker
  if (event->maker() != OrderEvent::kNaOrderId)
    if (event->maker() != boost::uuids::nil_uuid())
      buffer << to_string(event->maker()) << ",";
    else
      buffer << ",";
  else
    buffer << "NA,";

  // ordinal
  if (event->ordinal())
    buffer << event->ordinal() << ",";
  else
    buffer << ",";

  // timestamp, seconds
  auto s = toSeconds(event->timestamp().time_since_epoch());
  if(s != latest_seconds_) {
    using namespace std::chrono;
    latest_seconds_ = s;
    date::to_stream(buffer, "%FT%TZ,", time_point<system_clock,seconds>{s});
  }
  else
    buffer << ",";

  // timestamp, microseconds
  buffer << (event->timestamp().time_since_epoch() - s).count() << ",";

  // state
  if (event->state() != OrderEvent::OrderState::kNA) {
    if (event->state())
      buffer << event->state() << ",";
    else
      buffer << ",";
  } else
    buffer << "NA,";

  // price
  if (!std::isnan(event->price())) {
    std::ostringstream ss;
    ss << std::fixed << std::setprecision(quote_precision_) << event->price();
    buffer << removeTrailingZeros(ss.str()) << ",";
  } else
    buffer << "NA,";

  // volume
  if (!std::isnan(event->remaining())) {
    int sign = event->side() == OrderEvent::BookSide::kAsk ? -1 : 1;
    if (event->remaining()) {
      std::ostringstream ss;
      ss << std::fixed << std::setprecision(base_precision_) 
             << sign * event->remaining(); 
      buffer << removeTrailingZeros(ss.str()) << ",";
    }
    else
      buffer << ",";
  } else
    buffer << "NA,";

  // change
  if( !std::isnan(event->change())) {
    int sign = event->side() == OrderEvent::BookSide::kBid ? -1 : 1;
    if (event->change()) {
      std::ostringstream ss;
      ss << std::fixed << std::setprecision(base_precision_)
         << sign * event->change(); 
      buffer << removeTrailingZeros(ss.str()) << ",";
    } else
      buffer << ",";
  } else
    buffer << "NA,";

  // trade_id
  if (event->trade())
    buffer << event->trade() << ",";
  else
    buffer << ",";

  // taker
  if (event->taker() != OrderEvent::kNaOrderId)
    if (event->taker() != boost::uuids::nil_uuid())
      buffer << to_string(event->taker()) << ",";
    else
      buffer << ",";
  else
    buffer << "NA,";

  // heard
  if(event->heard() > event->timestamp())
    buffer << (event->heard() - event->timestamp()).count() << ",";
  else
    buffer << "0,";

  // deleted
  if(event->deleted())
    buffer << "1\n";
  else
    buffer << "\n";

  if(source_)
    s_ << event->source() << "\n";
  return (f_ << buffer.str()).good();
}
else 
 BOOST_LOG_TRIVIAL(error) << "Couldn't save " << event->toString();
return true;
!!!1092358.cpp!!!	era() : bool
using namespace date;
if(f_.is_open())
  f_.close();
auto base_name = name(security_->exchange, security_->product, received_->timestamp());
BOOST_LOG_TRIVIAL(info) <<   "Era file:    " << base_name << " quote_precision=" << quote_precision_
<< " base_precision=" << base_precision_;
f_.open(base_name);
f_ << "maker,ordinal,timestamp,mks,state,price,volume,change,trade,taker,heard,deleted\n";
if(source_) {
  if (s_.is_open())
    s_.close();
  s_.open(base_name + ".source");
  s_ << "\n"; // To ensure that line numbers in era and source files are the same for the same event
  BOOST_LOG_TRIVIAL(info) << "Source file: " << base_name + ".source";
}
return f_.is_open();
!!!1385606.cpp!!!	reset() : bool
if(f_.is_open()) f_.close();
if(s_.is_open()) s_.close();
latest_seconds_ = std::chrono::seconds{};
return true;
!!!1432838.cpp!!!	toSeconds(in d : microseconds) : seconds
using namespace std::chrono;
seconds t = duration_cast<seconds>(d);
if( t > d)
  return t - seconds{1};
else
  return t;
!!!1432966.cpp!!!	removeTrailingZeros(in str : string) : string
str.erase(str.find_last_not_of('0') + 1);
str.erase(str.find_last_not_of('.') + 1);
return std::move(str);
