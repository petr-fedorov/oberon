class Coinbase
!!!915590.cpp!!!	Coinbase()
  _current_state = 0;
!!!917382.cpp!!!	Coinbase(inout ioc : io_context, in host : string, in port : string, in target : string, in https_host : string, in https_port : string, in https_target : string, in product : string, in channel : string, in file_name : string)
https_ctx_ = std::make_unique<boost::asio::ssl::context>(
    boost::asio::ssl::context::sslv23_client);
load_root_certificates(*https_ctx_);
timer_ = std::make_unique<boost::asio::deadline_timer>(*ioc);
https_ = std::make_unique<SslStream>(*ioc, *https_ctx_);
signal_set_ = std::make_unique<boost::asio::signal_set>(*ioc, SIGINT, SIGTERM);

if (!SSL_set_tlsext_host_name(https_->native_handle(), https_host.c_str())) {
  boost::system::error_code ec{static_cast<int>(::ERR_get_error()),
                               boost::asio::error::get_ssl_category()};
  std::cerr << ec.message() << "\n";
}

/*
SSL_CTX_set_keylog_callback(https_ctx_->native_handle(),
      [](const SSL *ssl, const char *line) {
  ofstream f{"./key.txt", ios_base::app};
  f << line << "\n";
  f.close();
      });
*/
namespace http = boost::beast::http;
https_req_.method(http::verb::get);
https_req_.target(https_target + "/" + product + "/book?level=3");
https_req_.set(http::field::host, https_host);
https_req_.set(http::field::user_agent, BOOST_BEAST_VERSION_STRING);

using namespace boost::property_tree;
ptree p, h, c;

p.put("", product);
h.put("", "heartbeat");
c.put("", channel);

products_.push_back(std::make_pair("", p));
channels_.push_back(std::make_pair("", h));
channels_.push_back(std::make_pair("", c));
!!!915846.cpp!!!	create() : bool
if (_current_state == 0)
  (_current_state = &(*this)._coinbase_state)->create(*this);
return (_current_state != 0);
!!!916486.cpp!!!	doActivity() : void
  _current_state->_do(*this);
!!!916614.cpp!!!	_set_currentState(inout st : Coinbase::AnyState) : void
  _current_state = &st;
!!!916742.cpp!!!	_final() : void
  _current_state = 0;
#ifdef VERBOSE_STATE_MACHINE
    std::cout << "DEBUG : final state reached" << std::endl;
#endif
!!!925574.cpp!!!	heartbeat() : bool
  if (_current_state != 0) {
#ifdef VERBOSE_STATE_MACHINE
    std::cout << "DEBUG : fire trigger heartbeat" << std::endl;
#endif
    _current_state->heartbeat(*this);
  }
  return (_current_state != 0);
!!!927622.cpp!!!	message() : bool
  if (_current_state != 0) {
#ifdef VERBOSE_STATE_MACHINE
    std::cout << "DEBUG : fire trigger message" << std::endl;
#endif
    _current_state->message(*this);
  }
  return (_current_state != 0);
!!!935302.cpp!!!	dispatchJson(in ec : error_code) : void
// boost::ignore_unused(bytes_transferred);
using namespace boost::property_tree;
if (ec) {
  ec_ = ec;
  error_message_ = ec.message();
  std::cout << "dispatchJson: " << error_message_ << "\n";
  failure();
}
else {
  stringstream m;
  m << boost::beast::buffers(buffer_.data());
  tree_ = std::move(make_unique<ptree>());
  read_json(m, *tree_);

  buffer_.consume(buffer_.size());
  // std::cout << m.str() << std::endl;
  std::string msg_type{tree_->get<std::string>("type")};
  try {
    auto seq_number = tree_->get<long>("sequence");

    if (msg_type == "heartbeat") {
      if (seq_number == last_seq_number_ || !last_seq_number_)
        heartbeat();
      else {
        std::cout << "Heartbeat: Expected " << last_seq_number_ << " but got "
                  << seq_number << "\n";
        failure();
      }
    } else {

      if (!first_seq_number_) {
        first_seq_number_ = seq_number;
        last_seq_number_ = seq_number - 1;
        std::cout << "First sequence number : " << first_seq_number_ << "\n";
      }

      if (seq_number == last_seq_number_ + 1) {
        last_seq_number_ = seq_number;
        message();
      } else {
        std::cout << "Message : Expected " << last_seq_number_ + 1
                  << " but got " << seq_number << "\n";
        failure();
      }
    }
  } catch (const boost::property_tree::ptree_error &e) {
    if (msg_type == "error") {
      std::cout << tree_->get<std::string>("message") << std::endl;
      failure();
    } else if (msg_type == "subscriptions")
      success();
    else
      failure();
  };
}

!!!974726.cpp!!!	stop() : bool
  if (_current_state != 0) {
#ifdef VERBOSE_STATE_MACHINE
    std::cout << "DEBUG : fire trigger stop" << std::endl;
#endif
    _current_state->stop(*this);
  }
  return (_current_state != 0);
!!!976518.cpp!!!	timeout() : bool
  if (_current_state != 0) {
#ifdef VERBOSE_STATE_MACHINE
    std::cout << "DEBUG : fire trigger timeout" << std::endl;
#endif
    _current_state->timeout(*this);
  }
  return (_current_state != 0);
!!!1027078.cpp!!!	success() : bool
  if (_current_state != 0) {
#ifdef VERBOSE_STATE_MACHINE
    std::cout << "DEBUG : fire trigger success" << std::endl;
#endif
    _current_state->success(*this);
  }
  return (_current_state != 0);
!!!1027974.cpp!!!	failure() : bool
  if (_current_state != 0) {
#ifdef VERBOSE_STATE_MACHINE
    std::cout << "DEBUG : fire trigger failure" << std::endl;
#endif
    _current_state->failure(*this);
  }
  return (_current_state != 0);
